{"version":3,"sources":["api/pairs.js","components/AudioContext.jsx","components/About.jsx","components/Card.jsx","components/CardAndPocket.jsx","tools/utilities.js","components/Activity.jsx","components/Contact.jsx","api/views.js","components/Index.jsx","components/Preferences.jsx","components/MenuIcon.jsx","components/FullScreen.jsx","components/MenuItems.jsx","components/Menu.jsx","components/App.jsx","reportWebVitals.js","index.js"],"names":["currentPair","pairList","phonemeSymbols","phonemes","played","word1","word2","AudioContext","createContext","AudioProvider","children","audio","Audio","Provider","_stopAudioPlayback","pause","value","playClip","url","clip","src","startTime","duration","currentTime","setTimeout","play","then","result","catch","error","console","log","_startAudioPlayback","About","props","Card","forwardRef","cardRef","card","spelling","phonetic","image","image_","className","role","spaceName","taboo","useContext","action","ref","onMouseDown","onTouchStart","alt","CardAndPocket","listRef","index","cardData","phonemeData","phoneme","listOfCards","map","key","onClick","removeFrom","array","item","removeAll","found","removed","Array","isArray","reduce","excess","entry","findIndex","indexOf","splice","getPageXY","event","targetTouches","length","x","pageX","y","pageY","noDefault","preventDefault","setTrackedEvents","actions","drag","drop","body","document","type","move","end","addEventListener","passive","removeEventListener","pointWithin","rect","right","bottom","pairs","require","phonemePairs","Object","keys","AUDIO_DIR","setPhonemePair","pair","pairMap","entries","shift","_getPhonemeData","a","ii","jj","Math","floor","random","shuffle","undefined","_getWordData","word","words","data","getBoolean","lastFourValues","randomBoolean","hint","max","min","output","accumulator","push","getBooleanGenerator","Activity","cueURL","cueClip","cueSpace","cueCard","decoyURL","decoyClip","decoySpace","decoyCard","phoneme0","phoneme1","pockets","cancelTracking","cueRect","decoyRect","offset","mouseLoc","cueRef","useRef","decoyRef","phoneme0Ref","phoneme1Ref","useState","counter","setCounter","phoneme2","cards","getCards","playedCards","wrong","playCue","showWrong","classList","remove","add","showNextCard","hideOtherCard","playOtherCard","showOtherCard","moveIntoPocket","moveNearToPocket","playRightSequence","frame","getXY","style","left","top","forEach","pocket","checkForDrag","target","closest","contains","triggerDelta","trigger2","Promise","resolve","reject","startX","startY","options","deltaX","deltaY","cancel","detectMovement","stopPropagation","transitionDuration","cuePocket","querySelector","decoyPocket","getBoundingClientRect","startDrag","useSecondCard","createPockets","pocket1","pocket2","useEffect","current","Contact","Views","Index","itemClicked","bind","items","id","this","startActivity","getList","Component","Preferences","Icon","d","opacity","FullScreenButton","toggleFullScreen","docElm","documentElement","requestFullscreen","mozRequestFullScreen","webkitRequestFullScreen","msRequestFullscreen","exitFullscreen","mozCancelFullScreen","webkitCancelFullScreen","msExitFullscreen","component","isIOS","test","navigator","userAgent","isAppleDevice","includes","isTouchScreen","maxTouchPoints","volume","iosQuirkPresent","xmlns","viewBox","onMouseUp","width","height","stroke","class","asListItem","MenuItems","itemSelected","Items","closeMenu","selectFromMenu","pane","Menu","React","createRef","callback","openMenu","state","open","ignoreOpen","toggleMenu","listener","timeout","menu_open","setState","itemClass","preserveAspectRatio","App","view","setView","newView","View","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","getElementById","window","scrollTo"],"mappings":"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","file":"static/js/main.ea8cf6ce.chunk.js","sourcesContent":["/**\n * /src/api/pairs.js\n */\n\nimport { shuffle, removeFrom } from '../tools/utilities'\nconst pairs = require('../json/pairs.json')\n\n/** Export an array of pairs of phonemes that can be contrasted with\n * each other. This will be imported by the Index component\n */\nexport const phonemePairs = Object.keys(pairs.pairs)\n\nconst AUDIO_DIR = \"audio/\"\n\n// let taboo = false\n\nlet currentPair    // \"ɪi\" <<< one of the entries in phonemePairs\nlet pairList       // [ [ \"bitch\", \"beach\" ],...[ \"wheel\", \"will\" ] ]\nlet phonemeSymbols // [ \"ɪ\", \"iː\" ]\nlet phonemes       // [ { symbol: \"/ɪ/\", audio: [0, 1] }, ...]\n// let currentIndex   // 0\n// let lastIndex      // index of list item in pairList\nlet played         // { \"/x/\": [ <card>, ... ]\n                   // , \"/y/\": [ <card>, ... ]\n                   // }\nlet word1, word2   // \"bitch\", \"beach\"\n\n\n/**\n * Export a function to set the array of pairs that will produce the\n * next minimal pair of cards\n * \n * @param {string} pair: one ef the items from phonemePairs\n */\nexport function setPhonemePair(pair) {\n  if (currentPair === pair) {\n    return\n  }\n\n  // Choose the given pair, or the first available\n  const index = phonemePairs.indexOf(pair)\n  if (index < 0) {\n    pair = phonemePairs[0]\n  }\n\n  _setPairListAndPhonemeSymbols(pairs.pairs[pair])\n  // lastIndex = pairList.length - 1\n  // currentIndex = 0\n\n  // Ensure that the pockets start empty\n  word1 = word2 = undefined\n  played = { [phonemeSymbols[0]]:[], [phonemeSymbols[1]]:[] }\n\n  currentPair = pair\n}\n\n\n/**\n * Export a function to return all the data required to display a\n * minimal pair of words and play their audio files\n * \n * @returns \n */\nexport function getCards() {\n  const [ phoneme1, phoneme2 ] = phonemeSymbols\n\n  \n  if (word1) {\n    const spellings = played[phoneme1].map(word => word.spelling)\n    if (spellings.indexOf(word1.spelling) < 0) {\n      played[phoneme1].push(word1)\n      played[phoneme2].push(word2)\n    }\n  }\n\n  // Grab the first card and (for now) move it to the end\n  const cards = pairList.shift()\n  pairList.push(cards)\n\n  word1 = _getWordData(phoneme1, cards[0])\n  word2 = _getWordData(phoneme2, cards[1])\n\n  removeFrom(played[phoneme1], word1)\n  removeFrom(played[phoneme2], word2)\n\n  const output = {\n    phonemes\n  , word1\n  , word2\n  , played\n  }\n\n  return output\n}\n\n\n/**\n * @param {object} pairMap e.g. {\n *   \"ɑː\": \"ʌ\"       <<< phoneme pair\n * , \"heart\": \"hut\"  <<< minimal pairs\n * , \"barn\": \"bun\"\n * , ...\n * }\n */\nfunction _setPairListAndPhonemeSymbols(pairMap) {\n  pairList = Object.entries(pairMap)\n  // [[<ɪ>, <æ>], [<this>, <that>], [<tit>, <tat>], ...]\n\n  phonemeSymbols = pairList.shift()\n  // [[<ɪ>, <æ>]\n\n  phonemes = phonemeSymbols.map(_getPhonemeData)\n  shuffle(pairList)\n  // [[<tit>, <tat>], ..., [<this>, <that>], ...]\n}\n\n\n/**\n * \n * @param {string} phoneme (e.g.: \"ɑː\")\n * @param {string} word    (e.g.: \"heart\")\n * \n * @returns an object with a format like:\n * { \"spelling\": \"heart\"\n * , \"phonetic\": \"/hɑːt/\"\n * , \"image\": \"img/ɑ/heart.jpg\"\n * , \"clip\": [2.450, 3.550]\n * , url: \"audio/ɑ.mp3\"\n * }\n */\nfunction _getWordData(phoneme, word) {\n  const phonemeData = pairs.words[phoneme]\n  const data = {...phonemeData[word]}\n  data.url = AUDIO_DIR + phonemeData.url\n\n  return data\n}\n\n\n/**\n * Creates an object that allows the app to display the phoneme and\n * play its audio clip\n * \n * @param {string} phoneme (e.g. : \"ɑː\")\n * @returns an object with a format like:\n * { \"clip\": [ <startTime>, <endTime> ]\n * , url: <x.mp3>\n * , phoneme: <x>\n * }\n */\nfunction _getPhonemeData(phoneme) {\n  const phonemeData = pairs.words[phoneme]\n  const data = {...phonemeData[phoneme]}\n  data.url = AUDIO_DIR + phonemeData.url\n  data.phoneme = phoneme\n\n  return data\n}\n\n\nsetPhonemePair(\"ɑʌ\")","/**\n * src/components/AudioContext\n */\n\nimport React, { createContext } from 'react'\n\nexport const AudioContext = createContext()\n\nexport const AudioProvider = ({ children }) => {\n  // eslint-disable-next-line\n  const audio = new Audio()\n  // let playing = false\n\n  const Provider = AudioContext.Provider\n\n  const _stopAudioPlayback = () => {\n    audio.pause()\n    // playing = false\n  }\n\n  const _startAudioPlayback = (url, clip) => {\n    if (audio.src !== url) {\n      audio.src = url\n    }\n\n    const [ startTime, endTime ] = clip\n    const duration = (endTime - startTime) * 1000 // ms\n\n    audio.currentTime = startTime                  // s\n    setTimeout(_stopAudioPlayback, duration)\n\n    audio.play()\n         .then(result => {\n          //  playing = true\n         }).catch(error => {\n           console.log(\"Audio.play() error:)\", error)\n         })\n  }\n\n  const playClip = (url, clip) => {\n    // TODO: Fade out current audio playback before\n    // starting to play new clip.\n    _startAudioPlayback(url, clip)\n  }\n\n  return (\n    <Provider\n      value = {{\n        playClip\n      }}\n    >\n      {children}\n    </Provider>\n  )\n}","/**\n * /src/components/About.jsx\n */\n\n\nimport React from 'react';\n\n\nconst About = (props) => {\n  return (\n    <h1>About page goes here</h1>\n  )\n}\n\n\nexport default About","/**\n * /src/components/Card.jsx\n */\n\n\nimport React, { useContext, useEffect, forwardRef } from 'react'\nimport { AudioContext } from './AudioContext'\n\n\nconst Card = forwardRef((props, cardRef) => {\n  // console.log(\"card:\", props.card)\n  const {\n    spelling\n  , phonetic\n  , clip\n  , url\n  , image\n  , image_\n  } = props.card\n\n  const className = \"card\"\n                  + ( props.role\n                    ? \" flipped\"\n                    : \"\"\n                    )\n  const spaceName = \"card-holder\"\n                  + ( props.role\n                    ? \" space\"\n                    : \"\"\n                    )\n  const src = props.taboo ? (image_ || image) : image\n  const audio = useContext(AudioContext)\n  const action = props.action || (() => audio.playClip(url, clip))\n\n\n  return (\n    <div\n      className={spaceName}\n      ref={cardRef}\n    >\n      <div\n        className={className}\n        key={spelling}\n        onMouseDown={action}\n        onTouchStart={props.action}\n      >\n        <img\n          className=\"back unselectable\"\n          src=\"img/icons/sound.svg\"\n          alt=\"play audio icon\"\n        />\n        <div className=\"front unselectable\">\n          <img src={src} alt={spelling}/>\n          <p className=\"phonetic\">{phonetic}</p>\n          <p className=\"spelling\">{spelling}</p>\n        </div>\n      </div>\n    </div>\n  )\n})\n\n\nexport default Card","/**\n * /src/components/CardAndPocket.jsx\n *\n * This script creates a component which contains:\n *\n * - An unordered list of previously seen cards\n * - A two-sided card, whose z-index may change\n * - A \"pocket\" for the card and lists to be placed behind\n *\n * Stacking\n * --------\n * Each of these components will be absolutely placed, so that their\n * internal elements will belong to the same stacking context. The\n * container <div> will not be positioned, so co-ordinates will be\n * determined with respect to the <main> parent element. THere will be\n * two CardAndPocket components, one for the decoy card and one for the\n * cue card. The stacking will be as follows:\n *\n * <main (positioned by flex)>\n *   <div (not positioned)>\n *     <decoy list />\n *     <decoy card />\n *     <decoy pocket />\n *   </div>\n *   <div (not positioned>\n *     <cue list />\n *     <cue card />\n *     <cue pocket />\n *       (cue card when z-index is 1)\n *   </div>\n * </main>\n *\n *\n * Pocket\n * ------\n * The pocket will have a phonetic symbol on it, and a button with a\n * Play Audio icon. If you press this button, you will hear a recording\n * of the phonetic sound.\n *\n * Card\n * ----\n * The card will initially be displayed facing down. The Play Audio\n * symbol will appear on its back. On the front of the card will be\n * shown:\n * - A word\n * - A phonetic transcription of the word\n * - An image illustrating the word\n *\n * Pressing on the card (on either side) will play a recording of the\n * word.\n *\n * Previous Cards\n * --------------\n * The most recent card will be partly visible in the pocket. The\n * earlier cards will be hidden behind it. Clicking on the visible part\n * of the top card will play the audio associated with it.\n *\n * INTERACTIONS\n * ============\n * Interactions are controlled by the Activity.jsx script.\n *\n * Card Interactions\n * -----------------\n * The card may represent either a cue or a decoy. Another instance of\n * this component will create a matching decoy/cue Card and Pocket pair.\n *\n * If it is a cue, its audio recording will be played automatically.\n * If the user then either presses the matching pocket or drags the\n * card to the pocket, a Success Sequence will play:\n *\n * 1. The card will be placed over the pocket (z-index > 0)\n * 2. Its audio recording will play\n * 3. It will slide to the edge of the pocket...\n * 4. ... lose its z-index ...\n * 5. ... and slide in behind the pocket\n *\n * There are 3 preference settings to determine what happens next.\n * 1. By default, the associated decoy card will flip over, play its\n *    audio, then slide behind the other pocket\n * 2. If Play Similar Word is not checked, the associated decoy card\n *    will simply turn over and slide behind the other pocket\n * 3. If Compare With Similar Word is not checked, the associated decoy\n *    card will not even be shown.\n *\n * Interactions with Previous Cards\n * --------------------------------\n * A simple press on the visible part of a previous card will play its\n * word, so you can compare the words from the top card in each pocket.\n *\n * A prolonged press or a drag on a previous card will spread the cards\n * over the window:\n *\n * 1. All cards will be moved together to the far end,\n * 2. All cards from both pockets will be spread back towards the\n *    pocket, so that the top card in each set is over the pocket (just\n *    where it was when it was correctly played). It will not overlap\n *    any other card. The other cards will overlap equally, if there is\n *    not enough space for them to appear separately.\n * 3. Clicking on a wholly visible card will play its audio, and then\n *    the audio of the matching card in the other set\n * 4. Clicking on the visible part of a card which is overlapped will\n *    adjust the position of the other cards so that the clicked card\n *    is fully visible, and the cards either side are partly visible\n *    where other cards do not overlap them.\n *\n * At the place where the text \"Tap or drag to here\" is shown, a button\n * labelled \"Done\" will appear. Clicking on this will move all the\n * previously viewed cards into two piles at the edge of their\n * respective pockets, and then slide them in.\n */\n\nimport React, { useContext, forwardRef } from 'react'\nimport { AudioContext } from './AudioContext'\n\nimport Card from './Card'\n\nconst CardAndPocket = forwardRef((props, listRef) => {\n  const audio = useContext(AudioContext)\n  const {\n    index       // 0 | 1\n  , cardData    // { spelling, phonetic, image, url, clip }\n  , phonemeData // { phoneme, url, clip }\n  , role        // cue    | decoy\n  , cardRef     // cueRef | decoyRef\n  , played      // [ <card object>, ... ]\n  , action\n  } = props\n\n  const {\n    phoneme\n  , url\n  , clip\n  } = phonemeData\n\n  const card = (\n    <Card\n      card={cardData}\n      role={role}\n      ref={cardRef}\n      action={action}\n    />\n  );\n\n  const getCard = ( card, index ) => {\n    const key = card.spelling\n    return (\n      <li\n        key={key}\n      >\n        <Card\n          card={card}\n        />\n      </li>\n    )\n  }\n\n  const listOfCards = played.map(getCard)\n\n  const className = `phoneme-${index} ${role}`\n\n  return (\n    <div\n      className={className}\n      ref={listRef}\n    >\n      <ul>\n        {listOfCards}\n      </ul>\n\n      {card} {/* initially with z-index > 0 to appear above pocket */}\n\n      <div\n        className=\"pocket unselectable\"\n      >\n        /{phoneme}/\n\n        <button\n          className=\"play-phoneme\"\n          onClick={() => audio.playClip(url, clip)}\n        />\n      </div>\n    </div>\n   )\n})\n\nexport default CardAndPocket","/**\n * /imports/tools/generic/utilities.js\n *\n * Provides a set of re-usable functions which can be imported\n * anywhere\n */\n\n\n\n/// COLOR FUNCTIONS //\n\nexport const rgbify = (color) => {\n  if (color.substring(0, 3).toLowerCase() === \"hsl\" ) {\n    return HSLtoRGB(color)\n  }\n\n  if (color[0] === \"#\") {\n    color = color.slice(1)\n  }\n\n  if (color.length === 3) {\n    color = color[0]+color[0]+color[1]+color[1]+color[2]+color[2]\n  }\n\n  const hex = parseInt(color, 16)\n\n  return [\n    hex >> 16           // red\n  ,(hex >>  8) & 0x00FF // green\n  , hex        & 0xFF   // blue\n  ]\n}\n\n\n\nexport const tweenColor = (color1, color2, ratio) => {\n  const rgb1 = rgbify(color1)\n  const rgb2 = rgbify(color2)\n\n  const hex = rgb1.map((value, index) => {\n    value = Math.round(value - (value - rgb2[index]) * ratio)\n    value = Math.max(0, Math.min(value, 255))\n\n    return ((value < 16) ? \"0\" : \"\") + value.toString(16)\n  })\n\n  return \"#\" + hex.join(\"\")\n}\n\n\n\nexport const toneColor = (color, ratio) => {\n  const prefix = color[0] === \"#\"\n\n  if (prefix) {\n    color = color.slice(1)\n  }\n\n  const rgb = rgbify(color)\n             .map( value => {\n    value = Math.floor(Math.max(0, Math.min(255, value * ratio)))\n    return ((value < 16) ? \"0\" : \"\") + value.toString(16)\n  })\n\n  return (prefix ? \"#\" : \"\") + rgb.join(\"\")\n}\n\n\n\nexport const translucify = (color, opacity) => {\n  if (color[0] === \"#\") {\n    color = color.slice(1)\n  }\n\n  const rgb = rgbify(color)\n\n  return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`\n}\n\n\n// https://stackoverflow.com/a/20129594/1927589\n// https://qph.fs.quoracdn.net/main-qimg-aaa9a544d797f1109b29c55814319195.webp\nexport const getColor = ({ number, s=0.5, l=0.33, format=\"hsl\" }) => {\n  const h = number * 137.50776405 // ≈ golden angle: 180*(3-√5)\n\n  s = Math.max(0, Math.min(s, 1))\n  l = Math.max(0, Math.min(l, 1))\n\n  switch (format.toLowerCase()) {\n    case \"rgb\":\n      return hsl2rgb(h, s, l)\n\n    case \"hex\":\n      return hsl2hex(h, s * 100, l * 100)\n\n    default: // \"hsl\"\n      return `hsl(${h},${s*100}%,${l*100}%)`;\n  }\n}\n\n\n// https://stackoverflow.com/a/54014428/1927589\n// input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,1]\nexport const hsl2rgb = (h,s,l) => {\n  let a=s*Math.min(l,1-l);\n  let f= (n,k=(n+h/30)%12) => l - a*Math.max(Math.min(k-3,9-k,1),-1);\n  return [f(0),f(8),f(4)]\n}\n\n\n// https://stackoverflow.com/a/44134328/1927589\nexport const hsl2hex = (h, s, l) => {\n  h /= 360;\n  s /= 100;\n  l /= 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    const hue2rgb = (p, q, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  const toHex = x => {\n    const hex = Math.round(x * 255).toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n  };\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\n\n\n\nexport const HSLtoRGB = (colorString )=> {\n  // \"hsl(412.523,50%,40%)\" <<< percentages\n  // \"412.523, 0.5, 0.4\"    <<< ratios\n  let rgb = [0, 0, 0]\n\n  const regex = /(hsl\\s*\\(\\s*)?([0-9.]+)\\s*,\\s*([0-9.]+)(%?)\\s*,\\s*([0-9.]+)(%?)\\s*\\)?/\n  const match = regex.exec(colorString)\n\n  if (match) {\n    let h = parseFloat(match[2], 10)\n    let s = parseFloat(match[3], 10)\n    let l = parseFloat(match[5], 10)\n\n    while (h > 360) {\n      h -= 360\n    }\n    while (h < 0) {\n      h += 360\n    }\n    if (match[4]) {\n      s /= 100\n    }\n    s = Math.max(0, Math.min(s, 1))\n    if (match[6]) {\n      l /= 100\n    }\n    l = Math.max(0, Math.min(l, 1))\n\n    rgb = hsl2rgb(h, s, l) // [<0.0-1.0>, <0.0-1.0>, <0.0-1.0>]\n         .map(number => Math.round(number * 255))\n  }\n\n  return rgb\n}\n\n\n/**\n * @param   {<type>}  color   Must be a color (rgb or hex)\n * @param   {object}  values  May be an object with the same\n *                            structure as defaults\n * @return  {object}  Returns an object with the same structure as\n *                    defaults, but where each value is a color\n */\nexport const buttonColors = (color, values) => {\n  const output = {\n    restBg:     1\n  , restTint:   1.5\n  , restShade:  0.75\n\n  , overBg:    1.1\n  , overTint:  1.65\n  , overShade: 0.667\n\n  , downBg:    0.95\n  , downTint:  1.333\n  , downShade: 0.6\n  }\n  const keys = Object.keys(output)\n\n  ;(function merge(input) {\n    if (typeof input === \"object\") {\n      keys.forEach( key => {\n        const value = input[key]\n        if (!isNaN(value)) {\n          if (value > 0) {\n            output[key] = value\n          }\n        }\n      })\n    }\n  })()\n\n  keys.forEach( key => (\n    output[key] = toneColor(color, output[key])\n  ))\n\n  return output\n}\n\n\n/// ARRAY FUNCTIONS ///\n\nexport const removeFrom = (array, item, removeAll) => {\n  let removed = 0\n\n  // If `item` is an array of items or functions, treat recursively\n  if (Array.isArray(item)) {\n    removed = item.reduce((excess, entry) => {\n      excess += removeFrom(array, entry, removeAll)\n      return excess\n    }, 0)\n\n    return removed\n  }\n\n  // If we get here, item is an individual items or function\n  let index\n    , found\n\n  do {\n    if (typeof item === \"function\") {\n      index = array.findIndex(item)\n    } else {\n      index = array.indexOf(item)\n    }\n\n    found = !(index < 0)\n    if (found) {\n      array.splice(index, 1)\n      removed += 1\n    }\n  } while (removeAll && found)\n\n  return removed\n}\n\n\n\nexport const getDifferences = () => {\n  let  previous = []\n\n  return (array) => {\n    const plus = array.filter(item => previous.indexOf(item) < 0)\n    const minus = previous.filter(item => array.indexOf(item) < 0)\n    previous = [...array]\n\n    return { plus, minus }\n  }\n}\n\n\n\nexport const trackChanges = (array) => {\n  let  previous = [...array]\n\n  return () => {\n    const plus = array.filter(item => previous.indexOf(item) < 0)\n    const minus = previous.filter(item => array.indexOf(item) < 0)\n    previous = [...array]\n\n    return { plus, minus }\n  }\n}\n\n\n\nexport const shuffle = (a) => {\n  let ii = a.length\n\n  while (ii) {\n    const jj = Math.floor(Math.random() * ii)\n    ii -= 1;\n    [a[ii], a[jj]] = [a[jj], a[ii]]\n  }\n\n  return a // for chaining\n}\n\n\n\nexport const getRandom = (max, min = 0) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\n\n\nexport const getRandomFromArray = (array) => {\n  return array[Math.floor(Math.random() * array.length)]\n}\n\n\n/**\n * @returns either 0 or 1 but never more than 4 0s or 1s in a row\n *          and most likely not more than 3 in a row\n */\nexport const getBooleanGenerator = () => {\n  const lastFourValues = [0,1,0,1]\n\n  const randomBoolean = (hint=0) => {\n    const random = Math.max(0, Math.min(1, Math.random() * 2 + hint))\n    return Math.floor(random) // 0 | 1\n  }\n\n  return function booleanGenerator() {\n    let output\n\n    const sum = lastFourValues.reduce((accumulator, value) => {\n      return accumulator + value\n    }, 0)\n\n    switch (sum) {\n      case 0:\n        output = 1\n      break\n      case 1:\n        output = randomBoolean(0.5)\n      break\n      case 3:\n        output = randomBoolean(-0.5)\n      break\n      case 4:\n        output = 0\n      break\n      default:\n        output = randomBoolean()\n    }\n\n    lastFourValues.shift()\n    lastFourValues.push(output)\n\n    return output\n  }\n}\n\n\n\nexport const arrayOverlap = (array1, array2) => {\n  if (!array1 || !array1.length || !array2 || !array2.length) {\n    return []\n  }\n\n  return array1.filter( item => array2.includes(item) )\n}\n\n\n\nexport const getUnused = (source, used, tolerateDuplicates) => {\n  const unused = source.slice(0)\n  used.forEach(item => removeFrom(unused, item))\n  let item = getRandomFromArray(unused)\n\n  if (!item && tolerateDuplicates) {\n    // May return the same item multiple times,\n    // rather than creating a smooth spread\n    item = getRandomFromArray(source)\n  }\n\n  return item\n}\n\n\n\n/// MOUSE/TOUCH EVENT FUNCTIONS ///\n\nexport const getPageXY = (event) => {\n  if (event.targetTouches && event.targetTouches.length) {\n    event = event.targetTouches[0] || {}\n  }\n\n  return { x: event.pageX, y: event.pageY }\n}\n\n\n/**\n * clientX and ~Y refer to the position within the viewport\n * => This corresponds to the data returned by getBoundingClientRect()\n *    which is why it is used by default here\n *\n * pageX   and ~Y refer to the position within the entire document\n * offsetX and ~Y refer to the position within the target node\n */\nexport const getXY = (event, frame) => {\n  if ([\"client\", \"page\", \"offset\"].indexOf(frame) < 0) {\n    frame = \"client\"\n  }\n  if (event.targetTouches && event.targetTouches.length) {\n    event = event.targetTouches[0] || {}\n  }\n\n  return { x: event[frame + \"X\"], y: event[frame + \"Y\"] }\n}\n\n\n\n/**\n * Returns a promise which will be:\n * * resolved if the mouse or touch moves more than triggerDelta\n *   pixels in any direction\n * * rejected if the mouse is released/touch gesture ends before\n *   moving that far\n *\n * @param  {event}  event should be a mousedown or touchstart event\n * @param  {number} triggerDelta should be a positive number of pixels\n *\n * @return  {promise}\n */\nexport const detectMovement = (event, triggerDelta) => {\n  const trigger2 = triggerDelta * triggerDelta\n\n  function movementDetected(resolve, reject) {\n    const { x: startX, y: startY } = getPageXY(event)\n    const options = { event, drag, drop }\n    const cancel = setTrackedEvents(options)\n    // { actions: { move: <\"touchmove\" | \"mousemove\">\n    //              end:  <\"toucheend\" | \"mouseup\">\n    // , drag: function\n    // , drop: function\n    // }\n\n    // Check if the mouse/touch has moved more than triggerDelta\n    // pixels in any direction, and resolve promise if so.\n    function drag(event) {\n      const { x, y } = getPageXY(event)\n      const deltaX = startX - x\n      const deltaY = startY - y\n      const delta2 = (deltaX * deltaX + deltaY * deltaY)\n\n      if (delta2 > trigger2) {\n        setTrackedEvents(cancel)\n        resolve()\n      }\n    }\n\n    // Reject promise if the mouse is released before the mouse/touch\n    // moved triggerDelta pixels in any direction.\n    function drop(event) {\n      setTrackedEvents(cancel)\n      reject()\n    }\n  }\n\n  return new Promise(movementDetected)\n}\n\n\n// The prevent default function needs to be outside setTrackedEvents\n// so that the exact same function (rather than a duplicate)\nconst noDefault = (event) => event.preventDefault()\n\n\nexport const setTrackedEvents = ({ actions, event, drag, drop }) => {\n  // Omit event to cancel tracking\n  const body = document.body\n\n  const dragOption = { passive: false } // capture is false by default\n\n  if (event) {\n    if (typeof actions !== \"object\") {\n      actions = {}\n    }\n\n    if (event.type === \"touchstart\") {\n      actions.move  = \"touchmove\"\n      actions.end   = \"touchend\"\n    } else {\n      actions.move  = \"mousemove\"\n      actions.end   = \"mouseup\"\n    }\n\n    body.addEventListener(actions.move, drag, false)\n    body.addEventListener(actions.end, drop, false)\n    // Prevent the page scrolling during drag, or touch devices\n    document.addEventListener(\"touchstart\", noDefault, dragOption)\n\n  } else {\n    body.removeEventListener(actions.move, drag, false)\n    body.removeEventListener(actions.end, drop, false)\n    // Restore page scrolling on touche devices now that drag is over\n    document.removeEventListener(\"touchstart\", noDefault)\n  }\n\n  return { actions, drag, drop }\n}\n\n\n/// RECT & OBJECT FUNCTIONS ///\n\nexport const intersect = (rect1, rect2) => {\n  return rect1.x < rect2.right\n      && rect2.x < rect1.right\n      && rect1.y < rect2.bottom\n      && rect2.y < rect1.bottom\n}\n\n\n\nexport const intersection = (rect1, rect2) => {\n  const left   = Math.max( rect1.left || rect1.x || 0\n                         , rect2.left || rect2.x || 0\n                         )\n  const right  = Math.min( rect1.right||rect1.left+rect1.width||0\n                         , rect2.right||rect2.left+rect2.width||0\n                         )\n  if (!(left < right)) {\n    return 0\n  }\n\n  const top    = Math.max( rect1.top || rect1.y || 0\n                         , rect2.top || rect2.y || 0\n                         )\n  const bottom = Math.min( rect1.bottom||rect1.top+rect1.height||0\n                         , rect2.bottom||rect2.top+rect2.height||0\n                         )\n  if (!(top < bottom)) {\n    return 0\n  }\n\n  const x = left\n  const y = top\n  const width  = right - x\n  const height = bottom - y\n\n  return { x, y, left, right, top, bottom, width, height }\n}\n\n\n\nexport const union = (rects) => {\n  const [ rect, ...rest ] = rects\n  let { left, right, top, bottom } = rect\n\n  rest.forEach( rect => {\n    left   = Math.min(left,   rect.left)\n    right  = Math.max(right,  rect.right)\n    top    = Math.min(top,    rect.top)\n    bottom = Math.max(bottom, rect.bottom)\n  })\n\n  const x = left\n  const y = top\n  const width = right - left\n  const height = bottom - top\n\n  return { x, y, left, right, top, bottom, width, height }\n}\n\n\n\nexport const pointWithin = ( x, y, rect ) => {\n  if (typeof x === \"object\") {\n    if (typeof rect !== \"object\" && typeof y === \"object\") {\n      rect = y\n      y = x.y\n      x = x.x\n    }\n  }\n  return rect.x <= x\n      && rect.y <= y\n      && rect.right > x\n      && rect.bottom > y\n}\n\n\n/**\n * Calculates which fraction of rect shares it area with container\n */\nexport const overlap = (rect, container) => {\n  let overlap = intersection(rect, container) // 0 or rect object\n\n  if (overlap) {\n    const width  = rect.width || (rect.left - rect.right)\n    const height = rect.height || (rect.bottom - rect.top)\n    overlap = (overlap.width * overlap.height) / (width * height)\n  }\n\n  return overlap\n}\n\n\n\nexport const valuesMatch = (a, b) => {\n  if ( !a || typeof a !== \"object\" || !b || typeof b !== \"object\") {\n    return false\n  }\n\n  const propsA = Object.getOwnPropertyNames(a)\n  const propsB = Object.getOwnPropertyNames(b)\n\n  if (propsA.length !== propsB.length) {\n    return false\n  }\n\n  const total = propsA.length\n  for ( let ii = 0; ii < total; ii += 1 ) {\n    const prop = propsA[ii]\n\n    if (a[prop] !== b[prop]) {\n      return false\n    }\n\n    if (!removeFrom(propsB, prop)) {\n      // prop is undefined in a and missing in b\n      return false\n    }\n  }\n\n  return true\n}\n\n\n\nexport const valuesDontMatch = (a, b) => {\n  const nonMatching = {}\n\n  if ( !a || typeof a !== \"object\" || !b || typeof b !== \"object\") {\n    return { a, b }\n  }\n\n  const propsA = Object.getOwnPropertyNames(a)\n  const propsB = Object.getOwnPropertyNames(b)\n\n  propsA.forEach(prop => {\n    if (propsB.indexOf(prop) < 0) {\n      nonMatching[prop] = [\"delete\", a[prop]]\n\n    } else {\n      removeFrom(propsB, prop)\n\n      const valueA = a[prop]\n      const valueB = b[prop]\n\n      // if (path) {\n      //   prop = path + \".\"+ prop\n      // }\n\n      if (typeof valueA === \"object\" && typeof valueB === \"object\") {\n        const nested = valuesDontMatch(valueA, valueB)\n        if (nested) {\n          nonMatching[prop] = nested\n        }\n\n      } else if (valueA !== valueB) {\n        nonMatching[prop] = [\n          \"change\"\n       , getString(valueA)\n       , getString(valueB)\n       ]\n      }\n    }\n  })\n\n  propsB.forEach(prop => {\n    if (propsA.indexOf(prop) < 0) {\n      // if (path) {\n      //   prop = path + \".\"+ prop\n      // }\n\n      nonMatching[prop] = [\"insert\", getString(b[prop])]\n    }\n  })\n\n  if (Object.keys(nonMatching).length) {\n    return nonMatching\n  }\n}\n\n\n\nexport const deleteFrom = (object, key, removed) => {\n  if (typeof removed !== \"object\") {\n    removed = {}\n  }\n\n  // If `key` is an array of keys, treat recursively\n  if (Array.isArray(key)) {\n    key.forEach( entry => deleteFrom(object, entry, removed) )\n    return removed\n\n  } else if (key === undefined) {\n    key = (key, value) => (value === undefined || value === null)\n  }\n\n  // If we get here, key is an individual item\n  if (typeof key === \"function\") {\n    const keys = Object.keys(object)\n    keys.forEach( property => {\n      const value = object[property]\n      const deleteIt = key(property, value)\n      if (deleteIt) {\n        removed[property] = value\n        delete object[property]\n      }\n    })\n\n  } else if (object.hasOwnProperty(key)) {\n    removed[key] = object[key]\n    delete object[key]\n  }\n\n  return removed\n}\n\n\n// FONTS //\n\nexport const getFontFamily = (ff) => {\n  const start = ff.indexOf('family=')\n  if (start === -1) return 'sans-serif'\n  let end = ff.indexOf('&', start)\n  if(end === -1) end = undefined\n  ff = ff.slice(start + 7, end).replace(\"+\", \" \")\n  ff = '\"'+ ff + '\"'\n  return ff // + ', sans-serif'\n}\n\n\n// ENCRYPTION\n\n// by bryc https://stackoverflow.com/a/52171480/1927589\nexport const hash = (str, seed = 0) => {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\n  for (let i = 0, ch; i < str.length; i++) {\n      ch = str.charCodeAt(i)\n      h1 = Math.imul(h1 ^ ch, 2654435761)\n      h2 = Math.imul(h2 ^ ch, 1597334677)\n  }\n  h1 = Math.imul(h1 ^ (h1>>>16), 2246822507)\n     ^ Math.imul(h2 ^ (h2>>>13), 3266489909)\n  h2 = Math.imul(h2 ^ (h2>>>16), 2246822507)\n     ^ Math.imul(h1 ^ (h1>>>13), 3266489909)\n\n  return 4294967296 * (2097151 & h2) + (h1>>>0)\n}\n\n\n// IMAGES //\n\n// Inspired by https://ourcodeworld.com/articles/read/683/how-to-remove-the-transparent-pixels-that-surrounds-a-canvas-in-javascript\n// MIT http://rem.mit-license.org\nexport const trimImage = (image) => {\n  const c = document.createElement(\"canvas\")\n  c.width = image.width\n  c.height = image.height\n\n  const ctx = c.getContext('2d')\n  ctx.drawImage(image, 0, 0)\n\n  const copy = document.createElement('canvas').getContext('2d')\n  const pixels = ctx.getImageData(0, 0, c.width, c.height)\n  const l = pixels.data.length\n  const bound = {\n    top: null\n  , left: null\n  , right: null\n  , bottom: null\n  }\n  let ii\n    , x\n    , y\n\n  // Iterate over every pixel to find the highest\n  // and where it ends on every axis ()\n  for (ii = 0; ii < l; ii += 4) {\n      if (pixels.data[ii + 3] !== 0) {\n          x = (ii / 4) % c.width\n          y = ~~((ii / 4) / c.width)\n\n          if (bound.top === null) {\n              bound.top = y\n          }\n\n          if (bound.left === null) {\n              bound.left = x\n          } else if (x < bound.left) {\n              bound.left = x\n          }\n\n          if (bound.right === null) {\n              bound.right = x\n          } else if (bound.right < x) {\n              bound.right = x\n          }\n\n          if (bound.bottom === null) {\n              bound.bottom = y\n          } else if (bound.bottom < y) {\n              bound.bottom = y\n          }\n      }\n  }\n\n  // Calculate the height and width of the content\n  const trimHeight = bound.bottom - bound.top\n  const trimWidth = bound.right - bound.left\n  const trimmed = ctx.getImageData(\n    bound.left\n  , bound.top\n  , trimWidth\n  , trimHeight\n  )\n\n  // console.log(bound)\n\n  copy.canvas.width = trimWidth\n  copy.canvas.height = trimHeight\n  copy.putImageData(trimmed, 0, 0)\n\n  // Return an image\n  const trimmedImage = new Image()\n  trimmedImage.src =copy.canvas.toDataURL()\n\n  return trimmedImage\n}\n//\n// window.trimImage = trimImage\n\n\n\n// STRINGS //\n\n/** Adds customizable inserts to a string (e.g. Welcome <username>)\n *\n * @param      {string}  phrase   string OR\n *                                { simple:  \"Log in\"\n *                                , replace: \"Log in as ^0\"\n *                                }\n * @param     {object}   options  { \"^0\": \"admin\", ... }\n *\n * @return    {string}   string (with customized inserts)\n */\nexport const substitute = (phrase, options) => {\n  if (options && typeof options === \"object\") {\n    if (typeof phrase === \"object\") {\n      phrase = phrase.replace\n    }\n\n    for (let key in options) {\n      phrase = phrase.replace(key, options[key])\n    }\n\n  } else if (typeof phrase === \"object\") {\n    phrase = phrase.simple\n  }\n\n  // Replace underscores with non-breaking spaces\n  phrase = phrase.replace(/_/g, \" \")\n\n  return phrase\n}\n\n\n/**\n * Returns the best localized string from a map of phrases\n *\n * @param   {object}  phraseData   { ...\n *                                 , \"co-DE\": \"regional string\"\n *                                 , \"co\": \"generic string\"\n *                                 , \"xx\": {\n *                                     simple:  \"Log in\"\n *                                   , replace: \"Log in as ^0\"\n *                                   }\n *                                 , \"zz\": \"String with ^0 to replace\"\n *                                 , ...\n *                                 }\n * @param   {string}  code         language code ≈ \"co\" or \"co-DE\"\n * @param   {object}  options      { \"^0\": \"admin\", ... }\n *                                 OR\n *                                 \"as_is\", in which case any object\n *                                 containing simple and replace\n *                                 strings will be returned as an\n *                                 object\n *                                 OR\n *                                 other values are ignored\n *\n * @return  {string}  \"<Missing>\" or the localized string\n */\nexport const getLocalized = (phraseData, code = \"en\", options) => {\n  let phrase = phraseData[code]\n\n  if (!phrase) {\n    // Check if there is a more generic phrase without the region\n    const stripRegex = /-\\w+/\n    code = code.replace(stripRegex, \"\") // \"co-DE\" => \"co\"\n    phrase = phraseData[code]\n\n    if (!phrase) {\n      // Use any regional dialect of English as a fallback\n      const available = Object.keys(phraseData)\n      code = available.find(key => key.replace(stripRegex) === \"en\")\n\n      if (code) {\n        phrase = phraseData[code]\n      } else {\n        // Use the first available language\n        phrase = phraseData[available[0]]\n      }\n\n      if (!phrase) {\n        phrase = \"<Missing>\"\n      }\n    }\n  }\n\n  if (options !== \"as_is\") {\n    phrase = substitute(phrase, options)\n  }\n\n  return phrase\n}\n\n\n/** Selects a localized string from an array and customizes it\n *  replacing any (visible) underscores with (invisible)\n *  non-breaking spaces\n *\n * @param      {string}  cue     string cue value from corpus\n * @param      {string}  code    string language code, like \"co-DE\"\n * @param      {array}   corpus  [ { \"cue\": \"unique_string\"\n *                                 , \"co-DE\": \"fixed string\"\n *                                 , \"co\":    \"variable string ^0\"\n *                                 , ...\n *                                 }\n *                               , ...\n *                               ]\n * @param     {object}   options  { \"^0\": \"changeable part\", ...}\n *\n * @return    {string}   '***cue***' or localized string with &nbsp;\n */\nexport const localize = (cue, code, corpus, options) => {\n  let phrase\n\n  const phraseData = corpus.find(phrase => (\n    phrase.cue === cue\n  ))\n\n  if (phraseData) {\n    phrase = getLocalized(phraseData, code, options)\n  }\n\n  if (!phrase) {\n    console.log( \"Not found — cue:\", cue\n               , \"code:\", code\n               , \"phraseData:\", phraseData\n               )\n    phrase = \"***\" + cue + \"***\"\n  }\n\n  return phrase\n}\n\n\nexport const getString = item => {\n  const type = typeof item\n  try {\n    switch (type) {\n      case \"undefined\":\n        return \"undefined\"\n      case \"string\":\n      case \"object\":\n        return item\n      default:\n        if (item.toString) {\n          return item.toString()\n        } else {\n          return item\n        }\n    }\n  } catch {\n    return \"Unable to convert \" + type + \": \" + item\n  }\n}\n\n\n// HTML ELEMENTS //\n\n\n/** Returns index of the child of parentTag that contains element\n *\n * This is useful when you want to find (for instance) which list\n * item was selected, given that the event occurred on a child of the\n * list item.\n *\n * @param    {<type>}          element    An HTML element\n * @param    {string}          parentTag  The string tag of the parent\n *                                        of the element that contains\n *                                        `element`. \"UL\" by default.\n * @return   {integer}  -1 if element is not valid or if it does not\n *                      have a parent with the given tag, Non-negative\n *                      integer if the element's parent is found.\n */\nexport const getElementIndex = (element, parentTag) => {\n  let index = -1\n\n  if (element instanceof HTMLElement) {\n    parentTag = typeof parentTag === \"string\"\n              ? parentTag.toUpperCase()\n              : \"UL\"\n\n    while (element && element.parentNode.tagName !== parentTag) {\n      element = element.parentNode\n    }\n\n    if (element) {\n      const siblings = [].slice.call(element.parentNode.children)\n      index = siblings.indexOf(element)\n    }\n  }\n\n  return index\n}\n","import React, { useContext, useRef, useState, useEffect } from 'react'\nimport { AudioContext } from './AudioContext'\n\nimport './Activity.css';\nimport CardAndPocket from './CardAndPocket'\n\nimport { getCards } from '../api/pairs'\n\nimport { getBooleanGenerator\n       , detectMovement\n       , setTrackedEvents\n       , getPageXY\n       , getXY\n       , pointWithin\n} from '../tools/utilities'\nconst getBoolean = getBooleanGenerator()\n\n\n// <<< HARD-CODED\nconst REVIEW_DELAY = 2000;\nconst POCKET_DELAY = 200; // just a little more than transition-duration\nconst PLAY_DELAY = 1000\nconst NEXT_DELAY = 1000\nconst DEAL_DELAY = 300\n// HARD-CODED >>>\n\n\nconst Activity = (props) => {\n  // Shared with all cards and the Play Phoneme buttons\n  const audio = useContext(AudioContext)\n  // Used for animating cue and decoy cards\n  const cueRef = useRef()\n  const decoyRef = useRef()\n  // Used for presenting cards in pocket\n  const phoneme0Ref = useRef()\n  const phoneme1Ref = useRef()\n  // Used to tri0ger a re-render with a new card\n  const [counter, setCounter] = useState(0)\n\n  const {\n    phonemes\n  , word1\n  , word2\n  , played: playedCards\n  } = getCards() // imported from pairs.js\n\n  let wrong = false\n  let cueURL\n    , cueClip\n    , cueSpace\n    , cueCard\n    , decoyURL\n    , decoyClip\n    , decoySpace\n    , decoyCard\n    , phoneme0\n    , phoneme1\n    , pockets\n\n  // drag and drop\n  let cancelTracking\n    , cueRect\n    , decoyRect\n    , offset\n    , mouseLoc\n\n    // { \"phonemes\": [\n    //     { phoneme: \"ɪ\", audio: [0, 1], url: \"audio/ɪ.mp3\" }\n    //   , { phoneme: \"iː\", audio: [0, 11], url: \"audio/i.mp3\" }\n    //   ],\n    //   \"word1\": {\n    //     \"spelling\": \"ship\",\n    //     \"phonetic\": \"/∫ɪp/\",\n    //     \"image\": \"img/ship.jpg\",\n    //     \"url\": \"audio/ɪ.mp3\"\n    //     \"audio\": [\n    //       12.34,\n    //       13.24\n    //     ]\n    //   },\n    //   \"word2\": {\n    //     \"spelling\": \"sheep\",\n    //     \"phonetic\": \"/∫iːp/\",\n    //     \"image\": \"img/sheep.jpg\",\n    //     \"url\": \"audio/i.mp3\",\n    //     \"audio\": [\n    //       6.78,\n    //       7.68\n    //     ]\n    //   },\n    //   \"played\" {\n    //     \"ɪ\": [<card>, ...],\n    //     \"iː\": [<card>, ...]\n    //   }\n    // }\n\n\n  const playCue = () => {\n    audio.playClip(cueURL, cueClip)\n  }\n\n\n  // CHECKING THE ANSWER / CHECKING THE ANSWER / CHECKING THE ANSWER //\n\n  const showWrong = () => {\n    if (wrong) {\n      return\n    }\n\n    wrong = true\n    cueCard.classList.remove(\"flipped\")\n    phoneme0.classList.add(\"wrong\")\n    phoneme1.classList.add(\"wrong\")\n\n    cueSpace.classList.add(\"active\", \"outside-pocket\")\n    setTimeout(() => {\n      decoyCard.classList.remove(\"flipped\")\n      decoySpace.classList.add(\"active\", \"reveal\", \"outside-pocket\")\n    }, PLAY_DELAY )\n  }\n\n\n  /**\n   * Move cue card to the appropriate pocket\n   */\n  const showNextCard = () => {\n    cueSpace.classList.remove(\"active\", \"inside-pocket\")\n    decoySpace.classList.remove(\"reveal\", \"active\", \"inside-pocket\")\n\n    cueSpace.classList.add(\"deal\")\n    decoySpace.classList.add(\"deal\")\n\n    setCounter(counter + 1)\n  }\n\n\n  const hideOtherCard = () => {\n    decoySpace.classList.add(\"active\", \"inside-pocket\")\n    setTimeout(showNextCard, NEXT_DELAY)\n  }\n\n\n  const playOtherCard = () => {\n    audio.playClip(decoyURL, decoyClip)\n    setTimeout(hideOtherCard, PLAY_DELAY)\n  }\n\n\n  const showOtherCard = () => {\n    decoyCard.classList.remove(\"flipped\")\n    decoySpace.classList.add(\"reveal\")\n    setTimeout(playOtherCard, POCKET_DELAY)\n  }\n\n\n  const moveIntoPocket = () => {\n    cueSpace.classList.remove(\"outside-pocket\")\n    cueSpace.classList.add(\"inside-pocket\")\n\n    setTimeout(showOtherCard, POCKET_DELAY)\n  }\n\n\n  const moveNearToPocket = () => {\n    cueSpace.classList.add(\"outside-pocket\")\n    setTimeout(moveIntoPocket, POCKET_DELAY)\n  }\n\n\n  const playRightSequence = () => {\n    if (wrong) {\n      return\n    }\n\n    cueSpace.classList.add(\"active\")\n    audio.playClip(cueURL, cueClip)\n    setTimeout(moveNearToPocket, REVIEW_DELAY)\n  }\n\n\n  // Input from pockets and (>) button\n\n  const checkAnswer = event => {\n    const target = event.target\n    if (!target.classList.contains(\"pocket\")) {\n      return\n    }\n\n    const phoneme = target.closest(\"[class|=phoneme\")\n    // <div class=\"phoneme-X cue|decoy\">\n\n    cueCard.classList.remove(\"flipped\")\n\n    const correct = (phoneme.classList.contains(\"cue\"))\n    if (correct) {\n      playRightSequence()\n    } else {\n      showWrong()\n    }\n  }\n\n\n  const proceed = () => {\n    phoneme0.classList.remove(\"wrong\")\n    phoneme1.classList.remove(\"wrong\")\n\n    cueSpace.classList.remove(\"outside-pocket\")\n    decoySpace.classList.remove(\"outside-pocket\")\n\n    cueSpace.classList.add(\"inside-pocket\")\n    decoySpace.classList.add(\"inside-pocket\")\n    setTimeout(showNextCard, NEXT_DELAY)\n  }\n\n\n  // DRAG AND DROP // DRAG AND DROP // DRAG AND DROP // DRAG AND DROP //\n\n  const drag = (event) => {\n    const { x, y } = getPageXY(event)\n    mouseLoc = getXY(event) // will not be used until drop() is called\n\n    cueSpace.style.left = (offset.x + x )+ \"px\"\n    cueSpace.style.top =  (offset.y + y )+ \"px\"\n\n    // Highlight cueSpace or decoySpace if the mouse is over a pocket\n    ;[cueRect, decoyRect].forEach((rect, index) => {\n      const pocket = pockets[index]\n      if (pointWithin(mouseLoc, rect)) {\n        pocket.classList.add(\"hover\")\n      } else {\n        pocket.classList.remove(\"hover\")\n      }\n    })\n  }\n\n\n  const drop = () => {\n    setTrackedEvents(cancelTracking)\n    cueSpace.style = {}\n\n    pockets.forEach(pocket => pocket.classList.remove(\"hover\"))\n\n    if (pointWithin( mouseLoc, cueRect)) {\n      playRightSequence()\n\n    } else if (pointWithin( mouseLoc, decoyRect)) {\n      showWrong()\n\n    } else {\n      return // don't flip the card\n    }\n\n    cueCard.classList.remove(\"flipped\")\n\n  }\n\n\n  const startDrag = (event) => {\n    event.preventDefault()\n    event.stopPropagation()\n\n    cueSpace.style.transitionDuration = \"0s\"\n    const { x, y } = getPageXY(event)\n\n    const cuePocket = document.querySelector(\".cue .pocket\")\n    const decoyPocket = document.querySelector(\".decoy .pocket\")\n    cueRect = cuePocket.getBoundingClientRect()\n    decoyRect = decoyPocket.getBoundingClientRect()\n\n    const { left, top } = cueSpace.getBoundingClientRect()\n    offset = { x: left - x, y: top - y }\n\n    const options = {\n      event\n    , drag\n    , drop\n    }\n    cancelTracking = setTrackedEvents(options)\n  }\n\n\n  const checkForDrag = (event) => {\n    // console.log(\"event.type:\", event.type)\n    const target = event.target.closest(\".space\")\n\n    if (target) {\n      const classList = target.classList\n\n      if (classList.contains(\"active\") || classList.contains(\"reveal\")) {\n        return playCue()\n      }\n    }\n\n    detectMovement(event, 16)\n    .then(\n      () => startDrag(event)\n     )\n    .catch(playCue)\n  }\n\n\n  // GENERATING THE ACTIVITY LAYOUT // GENERATING THE ACTIVITY LAYOUT //\n\n  const createPockets = () => {\n    const useSecondCard = getBoolean()\n    let action\n\n    const pockets = phonemes.map((phonemeData, index) => {\n      // phonemeData = { phoneme, url, clip }\n\n      // Determine if this card is cue or decoy\n      const [ role, cardRef ]     = (index === useSecondCard)\n                                  ? [ \"decoy\", decoyRef ]\n                                  : [ \"cue\", cueRef]\n\n      // All the other properties depend on the phoneme\n      const [ cardData, listRef ] = index\n                                  ? [ word2, phoneme1Ref ]\n                                  : [ word1, phoneme0Ref ]\n      const played = playedCards[phonemeData.phoneme]\n\n      if (index !== useSecondCard) {\n        cueURL = cardData.url\n        cueClip = cardData.clip\n        action = checkForDrag\n\n      } else {\n        decoyURL = cardData.url\n        decoyClip = cardData.clip\n        action = null\n      }\n\n      return <CardAndPocket\n        index={index}\n        cardData={cardData}\n        phonemeData={phonemeData}\n        role={role}\n        cardRef={cardRef}\n        ref={listRef}\n        played={played}\n        action={action}\n      />\n    })\n\n    if (useSecondCard) {\n      // Show the cue card on top, by rendering it last\n      pockets.push(pockets.shift())\n    }\n\n    return pockets\n  }\n\n\n  const [ pocket1, pocket2 ] = createPockets()\n\n\n  useEffect(() => {\n    // eslint-disable-next-line\n    cueSpace = cueRef.current\n    // eslint-disable-next-line\n    decoySpace = decoyRef.current\n    // eslint-disable-next-line\n    phoneme0 = phoneme0Ref.current\n    // eslint-disable-next-line\n    phoneme1 = phoneme1Ref.current\n\n    // Pointers to DOM elements\n    if (phoneme0.classList.contains(\"cue\")) {\n      pockets = [\n        phoneme0.querySelector(\".pocket\")\n      , phoneme1.querySelector(\".pocket\")\n      ]\n    } else {\n      pockets = [\n        phoneme1.querySelector(\".pocket\")\n      , phoneme0.querySelector(\".pocket\")\n      ]\n    }\n\n    cueCard = cueSpace.querySelector(\".card\")\n    decoyCard = decoySpace.querySelector(\".card\")\n\n    decoySpace.classList.remove(\"deal\")\n    setTimeout(() => {\n      cueSpace.classList.remove(\"deal\")\n      playCue()\n    }, DEAL_DELAY )\n  })\n\n\n  return (\n    <div\n      className=\"activity\"\n      onClick={checkAnswer}\n    >\n      {pocket1}\n      {pocket2}\n      <p className=\"rule\">Tap or drag to here</p>\n      <button\n        className=\"done\"\n        onClick={proceed}\n      >\n        ➤\n      </button>\n    </div>\n  )\n}\n\nexport default Activity;\n","/**\n * /src/components/Contact.jsx\n */\n\n\nimport React from 'react';\n\n\nconst Contact = (props) => {\n return (\n   <h1>Contact page goes here</h1>\n )\n}\n\n\nexport default Contact","import About from '../components/About'\nimport Activity from '../components/Activity'\nimport Contact from '../components/Contact'\nimport Index from '../components/Index'\nimport Preferences from '../components/Preferences'\n\nconst Views = {\n  About\n, Activity\n, Contact\n, Index\n, Preferences\n}\n\nexport default Views","/**\n * /src/components/Index.jsx\n */\n\n\nimport React, { Component } from 'react';\nimport { phonemePairs, setPhonemePair } from '../api/pairs'\n\n\nclass Index extends Component {\n  constructor(props) {\n    super(props)\n\n    this.itemClicked = this.itemClicked.bind(this)\n  }\n\n\n  getList() {\n    const items = phonemePairs.map( pair => {\n      return (\n        <li\n          key={pair}\n          onClick={() => this.itemClicked(pair)}\n        >\n          {pair}\n        </li>\n      )\n    })\n\n    return (\n      <ul\n        id=\"index\"\n      >\n        {items}\n      </ul>\n    )\n  }\n\n\n  itemClicked(pair) {\n    setPhonemePair(pair)\n    this.props.startActivity()\n  }\n\n\n  render() {\n    const List = this.getList()\n    return List\n  }\n}\n\n\nexport default Index","/**\n * /src/components/Preferences.jsx\n */\n\n\nimport React from 'react';\n\n\nconst Preferences = (props) => {\n return (\n   <h1>Preferences page goes here</h1>\n )\n}\n\n\nexport default Preferences","/**\n * Creates an SVG hamburger menu\n */\n\n\nimport React from 'react';\n\nconst Icon = () => (\n  <g className=\"menu\">\n    <path d=\"\n      M5,20\n      L5,80\n      H95\n      L95,20\n      z\" opacity=\"0\" />\n    <path d=\"\n      M15,10\n      H85\n      a 10 10 180 0 1 0 20\n      H15\n      a 10 10 180 0 1 0 -20\n      z\" />\n    <path d=\"\n      M15,40\n      H85\n      a 10 10 180 0 1 0 20\n      H15\n      a 10 10 180 0 1 0 -20\n      z\" />\n    <path d=\"\n      M15,70\n      H85\n      a 10 10 180 0 1 0 20\n      H15\n      a 10 10 180 0 1 0 -20\n      z\" />\n  </g>\n)\n\nexport default Icon","/**\n * \n */\n\nimport './FullScreen.css'\n\nexport const FullScreenButton = (props) => {\n  const toggleFullScreen = () => {\n    const docElm = document.documentElement;\n    if (docElm.requestFullscreen) {\n        docElm.requestFullscreen();\n    } else if (docElm.mozRequestFullScreen) {\n        docElm.mozRequestFullScreen();\n    } else if (docElm.webkitRequestFullScreen) {\n        docElm.webkitRequestFullScreen();\n    } else if (docElm.msRequestFullscreen) {\n        docElm.msRequestFullscreen();\n    }\n\n    if (document.exitFullscreen) {\n      document.exitFullscreen().catch(()=>{});\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen().catch(()=>{});\n    } else if (document.webkitCancelFullScreen) {\n      document.webkitCancelFullScreen().catch(()=>{});\n    } else if (document.msExitFullscreen) {\n      document.msExitFullscreen().catch(()=>{});\n    }\n  }\n\n  const isIOS = (() => {\n    var iosQuirkPresent = function () {\n        var audio = new Audio();\n\n        audio.volume = 0.5;\n        return audio.volume === 1;   // volume cannot be changed from \"1\" on iOS 12 and below\n    };\n\n    var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);\n    var isAppleDevice = navigator.userAgent.includes('Macintosh');\n    var isTouchScreen = navigator.maxTouchPoints >= 1;   // true for iOS 13 (and hopefully beyond)\n\n    return isIOS || (isAppleDevice && (isTouchScreen || iosQuirkPresent()));\n  })();\n  // https://stackoverflow.com/a/62094756/1927589pd\n  \n  const SVGButton = () => (\n    <svg\n      id=\"fullscreen-btn\"\n      xmlns=\"http://www.w3.org/2100/svg\"\n      viewBox=\"0 0 100 100\"\n      onMouseUp={toggleFullScreen}\n      onClick={props.onClick}\n    >\n\n      <rect\n        width=\"100\"\n        height=\"100\"\n        stroke=\"white\"\n        stroke-width=\"1\"\n        opacity=\"0\"\n      />\n\n      <path\n        class=\"collapse\"\n        d=\"\n          M 45 55\n          v 27\n          a 5 5 0 0 1 -10 0\n          v -10\n          l -21 21\n          a 5 5 0 0 1 -7.07 -7.07\n          l 21 -21\n          h -10\n          a 5 5 0 0 1 0 -10\n          Z\n\n          M 55 45\n          v -27\n          a 5 5 0 0 1 10 0\n          v 10\n          l 21 -21\n          a 5 5 0 0 1 7.07 7.07\n          l -21 21\n          h 10\n          a 5 5 0 0 1 0 10\n          Z\n        \"\n      />\n\n      <path\n        class=\"expand\"\n        d=\"\n          M 95 5\n          v 27\n          a 5 5 0 0 1 -10 0\n          v -10\n          l -21 21\n          a 5 5 0 0 1 -7.07 -7.07\n          l 21 -21\n          h -10\n          a 5 5 0 0 1 0 -10\n          Z\n\n          M 5 95\n          v -27\n          a 5 5 0 0 1 10 0\n          v 10\n          l 21 -21\n          a 5 5 0 0 1 7.07 7.07\n          l -21 21\n          h 10\n          a 5 5 0 0 1 0 10\n          Z\n        \"\n      />\n    </svg>\n  )\n\n  let component = isIOS ? \"\" : SVGButton()\n  \n  if (component && props.asListItem) {\n    component = (\n      <li\n        className=\"fullscreen\"\n        key=\"fullscreen\"\n      >\n        {component}\n      </li>\n    )\n  }\n\n  return component\n}","/**\n * /src/components/MenuItems.jsx\n */\n\n\nimport React, { Fragment } from 'react';\nimport { FullScreenButton } from './FullScreen'\n\nconst MenuItems = ({ itemSelected }) => {\n  return (\n    <>\n      <FullScreenButton\n        onClick={itemSelected}\n      />\n      <li\n        className=\"unselectable\"\n        key=\"index\"\n        onClick={() => itemSelected(\"Index\")}\n      >\n        Select minimal pair\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"activity\"\n        onClick={() => itemSelected(\"Activity\")}\n      >\n        Return to activity\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"preferencs\"\n        onClick={() => itemSelected(\"Preferences\")}\n      >\n        Preferences\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"about\"\n        onClick={() => itemSelected(\"About\")}\n      >\n        About this activity\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"contact\"\n        onClick={() => itemSelected(\"Contact\")}\n      >\n        Contact us\n      </li>\n    </>\n  )\n}\n\n\nexport default MenuItems","/**\n * /imports/ui/Menu.jsx\n *\n * The Menu consists of three parts:\n * 1. A full-height background that slides in and out\n * 2. A list of clickable item that is a child of the background\n * 3. A hamburger icon which:\n *    • Is always visible\n *    • Slides out in sync with the background when the background's\n *      right edge is flush with the icon's right edge\n *    • Slides back in in sync with the background, until the\n *      background's right edge is less than the icon's width\n *    • Becomes semi-transparent when the background is not showing\n *    • Brightenes to full opacity when the background slides out\n * Clicking on the hamburger icon makes the background slide out or\n * back in again. Clicking anywhere outside the background while it\n * is visible will make it slide back in again.\n *\n * Clicking on on of the clickable items in the list will trigger\n * that item and slide the menu back in.\n */\n\nimport React, { Component } from 'react';\nimport './Menu.css';\nimport Icon from './MenuIcon'\nimport MenuItems from './MenuItems'\n\n\nconst CLOSE_MENU_DELAY = 1000\n\n\nconst Items = (props) => {\n  const { closeMenu, selectFromMenu, pane, className } = props\n\n  const itemSelected = (item) => {\n    closeMenu(true) // force menu to close even if timeOut is active\n    if (typeof item === \"string\") {\n      selectFromMenu(item)\n    }\n  }\n\n  return <ul\n    id=\"items\"\n    className={className}\n    ref={pane}\n  >\n    <MenuItems\n      itemSelected={itemSelected}\n    />\n  </ul>\n}\n\n\n\nclass Menu extends Component {\n  constructor(props) {\n    super(props)\n\n    this.pane = React.createRef()\n\n    this.callback = props.callback // <<<<<\n\n    this.openMenu = this.openMenu.bind(this)\n    this.closeMenu = this.closeMenu.bind(this)\n    this.state = { open: true }\n\n    this.openMenu()\n    setTimeout(this.closeMenu, CLOSE_MENU_DELAY)\n  }\n\n\n  openMenu(event) {\n    if (this.ignoreOpen) {\n      return\n    }\n\n    if (event) {\n      this.toggleMenu(true)\n    }\n\n    const listener = this.closeMenu\n    document.body.addEventListener(\"touchstart\", listener, true)\n    document.body.addEventListener(\"mousedown\", listener, true)\n  }\n\n\n  closeMenu(event) {\n    // Check if the click was inside the slide-out menu. If not,\n    // close the menu\n\n    if (event && (event === true || event.type === \"touchstart\")) {\n      // Prevent the mouseup from firing right behind\n      this.timeout = setTimeout(() => {\n        this.timeout = 0\n      }, 300)\n      // console.log(\"Menu closeMenu timeout\", this.timeOut)\n    } else if (this.timeout) {\n      return\n    }\n\n    const pane = this.pane.current\n    if (!event || (pane && !pane.contains(event.target))) {\n      this.toggleMenu(false)\n      // Prevent the menu from reopening immediately if the click to\n      // close was on the Icon\n\n      this.ignoreOpen = true\n      setTimeout(() => this.ignoreOpen = false, 100)\n      // console.log(\"Menu closeMenu timeout\", timeOut)\n\n      const listener = this.closeMenu\n      document.body.removeEventListener(\"touchstart\", listener,true)\n      document.body.removeEventListener(\"mousedown\", listener, true)\n    }\n  }\n\n\n  toggleMenu(menu_open) {\n    const open = !this.state.open\n    this.setState({ open })\n  }\n\n\n  render() {\n    const itemClass = this.state.open ? \"open\" : \"\"\n\n    return <div\n        id=\"menu\"\n      >\n        <Items\n          {...this.props}\n          className={itemClass}\n          pane={this.pane}\n          closeMenu={this.closeMenu}\n        />\n        <svg\n          id=\"openMenu\"\n          viewBox=\"0 0 100 100\"\n          preserveAspectRatio=\"xMidYMid meet\"\n\n          onClick={this.openMenu}\n        >\n          <Icon />\n        </svg>\n      </div>\n  }\n}\n\nexport default Menu","import React, { useState } from \"react\";\nimport { AudioProvider } from \"./AudioContext\"\n\nimport Views from \"../api/views\";\nimport Menu from \"./Menu\";\n\n\nconst App = (props) => {\n  const [ view, setView ] = useState(\"Activity\")\n\n  const selectFromMenu = (newView) => {\n    if (!newView) {\n      newView = \"Activity\"\n    }\n\n    setView(newView)\n  }\n\n  const View = Views[view];\n\n  return (\n    <AudioProvider>\n      <main className=\"split left--handed show--phonetic show-cue-image\">\n        <View\n          startActivity={selectFromMenu}\n        />\n        <Menu\n          selectFromMenu={selectFromMenu}\n        />\n      </main>\n    </AudioProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\n// ReactDOM.render(\n//   <React.StrictMode>\n//     <App />\n//   </React.StrictMode>,\n//   document.getElementById('root')\n// );\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\nwindow.addEventListener(\"load\",function() {\n  setTimeout(function(){\n      // This hides the address bar:\n      window.scrollTo(0, 1);\n  }, 0);\n});\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
{"version":3,"sources":["api/pairs.js","components/Card.jsx","components/Audio.jsx","tools/utilities.js","components/Pocket.jsx","components/App.jsx","reportWebVitals.js","index.js"],"names":["currentPair","pairList","phonemeSymbols","phonemes","played","word1","word2","Card","Component","props","card","spelling","phonetic","image","image_","className","role","src","taboo","onMouseDown","alt","pairs","require","phonemePairs","Object","keys","_getWordData","phoneme","word","words","_getPhonemeData","data","pair","pairMap","indexOf","entries","shift","map","a","ii","length","jj","Math","floor","random","shuffle","setPhonemePair","Pocket","index","audio","playAudio","getCard","cardList","listOfCards","getCardList","onClick","App","useFirstCard","bind","state","phoneme1","phoneme2","unshift","cards","push","getCards","console","log","this","phonemeData","card1","card2","getPockets","pocket1","pocket2","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.126b0e04.chunk.js","sourcesContent":["/**\n * /src/api/pairs.js\n */\n\nimport { shuffle } from '../tools/utilities'\nconst pairs = require('../json/pairs.json')\n\n// console.log(\"initializing pairs.js:\")\n// console.log(\"pairs:\", pairs)\n \nconst phonemePairs = Object.keys(pairs.pairs)\nlet taboo = false\n\nlet currentPair    // \"ɪi\" <<< one of the entries in phonemePairs\nlet pairList       // [ [ \"bitch\", \"beach\" ],...[ \"wheel\", \"will\" ] ]\nlet phonemeSymbols // [ \"ɪ\", \"iː\" ]\nlet phonemes       // [ { symbol: \"/ɪ/\", audio: [0, 1] }, ...]\nlet currentIndex   // 0\nlet lastIndex      // index of list item in pairList\nlet played         // { \"/x/\": [ <card>, ... ]\n                   // , \"/y/\": [ <card>, ... ]\n                   // }\nlet word1, word2   // \"bitch\", \"beach\"\n\n\n\nexport function getPhonemePairs() {\n  return phonemePairs\n}\n\nexport function setPhonemePair(pair) {\n  if (currentPair === pair) {\n    return\n  }\n\n  // Choose the given pair, or the first available\n  const index = phonemePairs.indexOf(pair)\n  if (index < 0) {\n    pair = phonemePairs[0]\n  }\n \n  _setPairListAndPhonemeSymbols(pairs.pairs[pair])\n  lastIndex = pairList.length - 1\n  currentIndex = 0\n  played = { [phonemeSymbols[0]]:[], [phonemeSymbols[1]]:[] }\n\n  currentPair = pair\n}\n\nexport function getCards() {\n  const [ phoneme1, phoneme2 ] = phonemeSymbols\n  \n  if (word1) {\n    played[phoneme1].unshift(word1)\n    played[phoneme2].unshift(word2)\n  }\n\n  // Grab the first card and (for now) move it to the end\n  const cards = pairList.shift()\n  pairList.push(cards)\n\n  word1 = _getWordData(phoneme1, cards[0])\n  word2 = _getWordData(phoneme2, cards[1]) \n  \n  const output = {\n    phonemes\n  , word1\n  , word2\n  , played\n  }\n\n  return output\n}\n\nfunction _setPairListAndPhonemeSymbols(pairMap) {\n  pairList = Object.entries(pairMap)\n  // [[<ɪ>, <æ>], [<this>, <that>], [<tit>, <tat>], ...]\n  phonemeSymbols = pairList.shift()\n  phonemes = phonemeSymbols.map(_getPhonemeData)\n  shuffle(pairList)\n\n  // console.log(\"pairList:\", pairList)\n  // console.log(\"phonemeSymbols:\", phonemeSymbols)\n}\n\nfunction _getWordData(phoneme, word) {\n  const data = pairs.words[phoneme][word]\n\n  return data\n}\n\n\nfunction _getPhonemeData(phoneme) {\n  const data = {...pairs.words[phoneme][phoneme]}\n  data.phoneme = phoneme\n  // { audio: [ <startTime>, <endTime> ]\n  // , phoneme: <x>\n  // }\n  return data\n}\n\n\nsetPhonemePair(\"ɑʌ\")","/**\n * /src/components/Card.jsx\n */\n\n\nimport React from 'react';\n\n\nconst Card = (props) => {\n  const { spelling, phonetic, image, image_ } = props.card\n  const className = \"card\"\n                  + ( props.role\n                    ? ` ${props.role}`\n                    : \"\"\n                    )\n  const src = props.taboo ? (image_ || image) : image\n\n  return (\n    <div\n      className={className}\n      key={spelling}\n      onMouseDown={props.onMouseDown}\n    >\n      <img className=\"icon\" src=\"img/icons/sound.svg\" alt=\"play icon\" />\n      <img className=\"illustration\" src={src} alt={spelling}/>\n      <p className=\"phonetic\">{phonetic}</p>\n      <p className=\"spelling\">{spelling}</p>\n    </div>\n  )\n}\n\n\nexport default Card","import React, {Component} from 'react'\n\n\nclass AudioElement extends Component {\n  constructor(props) {\n    super(props)\n    this.playing = false\n    this.audio = new Audio(this.props.url)\n\n    this.startAudioPlayback = this.startAudioPlayback.bind(this)\n    this.stopAudioPlayback = this.stopAudioPlayback.bind(this)\n    this.togglePlayback = this.togglePlayback.bind(this)\n  }\n\n  startAudioPlayback() {\n    this.audio.currentTime = this.props.startTime\n    setTimeout(this.stopAudioPlayback, this.props.duration * 1000)\n\n    try {\n      this.audio.play()\n      this.playing = true\n    } catch(error) {\n      // User needs to click before audio can be played\n    }\n  }\n  \n  stopAudioPlayback() {\n    this.audio.pause()\n    this.playing = false\n  }\n\n  togglePlayback() {\n    if (this.playing) {\n      this.stopAudioPlayback()\n    } else {\n      this.startAudioPlayback()\n    }\n  }\n\n  render() {\n    return (\n      <button onClick={this.togglePlayback}>\n        Play\n      </button>\n    );\n  }\n\n  componentDidMount() {\n    this.audio.onended = this.stopAudioPlayback;\n    this.startAudioPlayback()\n  }\n\n  componentDidUpdate() {\n    this.startAudioPlayback()\n  }\n  \n  componentWillUnmount() {\n    this.audio.onended = null;\n    this.stopAudioPlayback()\n  }\n}\n\nexport default AudioElement;\n","/**\n * /imports/tools/generic/utilities.js\n *\n * Provides a set of re-usable functions which can be imported\n * anywhere\n */\n\n\n\n/// COLOR FUNCTIONS //\n\nexport const rgbify = (color) => {\n  if (color.substring(0, 3).toLowerCase() === \"hsl\" ) {\n    return HSLtoRGB(color)\n  }\n\n  if (color[0] === \"#\") {\n    color = color.slice(1)\n  }\n\n  if (color.length === 3) {\n    color = color[0]+color[0]+color[1]+color[1]+color[2]+color[2]\n  }\n\n  const hex = parseInt(color, 16)\n\n  return [\n    hex >> 16           // red\n  ,(hex >>  8) & 0x00FF // green\n  , hex        & 0xFF   // blue\n  ]\n}\n\n\n\nexport const tweenColor = (color1, color2, ratio) => {\n  const rgb1 = rgbify(color1)\n  const rgb2 = rgbify(color2)\n\n  const hex = rgb1.map((value, index) => {\n    value = Math.round(value - (value - rgb2[index]) * ratio)\n    value = Math.max(0, Math.min(value, 255))\n\n    return ((value < 16) ? \"0\" : \"\") + value.toString(16)\n  })\n\n  return \"#\" + hex.join(\"\")\n}\n\n\n\nexport const toneColor = (color, ratio) => {\n  const prefix = color[0] === \"#\"\n\n  if (prefix) {\n    color = color.slice(1)\n  }\n\n  const rgb = rgbify(color)\n             .map( value => {\n    value = Math.floor(Math.max(0, Math.min(255, value * ratio)))\n    return ((value < 16) ? \"0\" : \"\") + value.toString(16)\n  })\n\n  return (prefix ? \"#\" : \"\") + rgb.join(\"\")\n}\n\n\n\nexport const translucify = (color, opacity) => {\n  if (color[0] === \"#\") {\n    color = color.slice(1)\n  }\n\n  const rgb = rgbify(color)\n\n  return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`\n}\n\n\n// https://stackoverflow.com/a/20129594/1927589\n// https://qph.fs.quoracdn.net/main-qimg-aaa9a544d797f1109b29c55814319195.webp\nexport const getColor = ({ number, s=0.5, l=0.33, format=\"hsl\" }) => {\n  const h = number * 137.50776405 // ≈ golden angle: 180*(3-√5)\n\n  s = Math.max(0, Math.min(s, 1))\n  l = Math.max(0, Math.min(l, 1))\n\n  switch (format.toLowerCase()) {\n    case \"rgb\":\n      return hsl2rgb(h, s, l)\n\n    case \"hex\":\n      return hsl2hex(h, s * 100, l * 100)\n\n    default: // \"hsl\"\n      return `hsl(${h},${s*100}%,${l*100}%)`;\n  }\n}\n\n\n// https://stackoverflow.com/a/54014428/1927589\n// input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,1]\nexport const hsl2rgb = (h,s,l) => {\n  let a=s*Math.min(l,1-l);\n  let f= (n,k=(n+h/30)%12) => l - a*Math.max(Math.min(k-3,9-k,1),-1);\n  return [f(0),f(8),f(4)]\n}\n\n\n// https://stackoverflow.com/a/44134328/1927589\nexport const hsl2hex = (h, s, l) => {\n  h /= 360;\n  s /= 100;\n  l /= 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    const hue2rgb = (p, q, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  const toHex = x => {\n    const hex = Math.round(x * 255).toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n  };\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\n\n\n\nexport const HSLtoRGB = (colorString )=> {\n  // \"hsl(412.523,50%,40%)\" <<< percentages\n  // \"412.523, 0.5, 0.4\"    <<< ratios\n  let rgb = [0, 0, 0]\n\n  const regex = /(hsl\\s*\\(\\s*)?([0-9.]+)\\s*,\\s*([0-9.]+)(%?)\\s*,\\s*([0-9.]+)(%?)\\s*\\)?/\n  const match = regex.exec(colorString)\n\n  if (match) {\n    let h = parseFloat(match[2], 10)\n    let s = parseFloat(match[3], 10)\n    let l = parseFloat(match[5], 10)\n\n    while (h > 360) {\n      h -= 360\n    }\n    while (h < 0) {\n      h += 360\n    }\n    if (match[4]) {\n      s /= 100\n    }\n    s = Math.max(0, Math.min(s, 1))\n    if (match[6]) {\n      l /= 100\n    }\n    l = Math.max(0, Math.min(l, 1))\n\n    rgb = hsl2rgb(h, s, l) // [<0.0-1.0>, <0.0-1.0>, <0.0-1.0>]\n         .map(number => Math.round(number * 255))\n  }\n\n  return rgb\n}\n\n\n/**\n * @param   {<type>}  color   Must be a color (rgb or hex)\n * @param   {object}  values  May be an object with the same\n *                            structure as defaults\n * @return  {object}  Returns an object with the same structure as\n *                    defaults, but where each value is a color\n */\nexport const buttonColors = (color, values) => {\n  const output = {\n    restBg:     1\n  , restTint:   1.5\n  , restShade:  0.75\n\n  , overBg:    1.1\n  , overTint:  1.65\n  , overShade: 0.667\n\n  , downBg:    0.95\n  , downTint:  1.333\n  , downShade: 0.6\n  }\n  const keys = Object.keys(output)\n\n  ;(function merge(input) {\n    if (typeof input === \"object\") {\n      keys.forEach( key => {\n        const value = input[key]\n        if (!isNaN(value)) {\n          if (value > 0) {\n            output[key] = value\n          }\n        }\n      })\n    }\n  })()\n\n  keys.forEach( key => (\n    output[key] = toneColor(color, output[key])\n  ))\n\n  return output\n}\n\n\n/// ARRAY FUNCTIONS ///\n\nexport const removeFrom = (array, item, removeAll) => {\n  let removed = 0\n\n  // If `item` is an array of items or functions, treat recursively\n  if (Array.isArray(item)) {\n    removed = item.reduce((excess, entry) => {\n      excess += removeFrom(array, entry, removeAll)\n      return excess\n    }, 0)\n\n    return removed\n  }\n\n  // If we get here, item is an individual items or function\n  let index\n    , found\n\n  do {\n    if (typeof item === \"function\") {\n      index = array.findIndex(item)\n    } else {\n      index = array.indexOf(item)\n    }\n\n    found = !(index < 0)\n    if (found) {\n      array.splice(index, 1)\n      removed += 1\n    }\n  } while (removeAll && found)\n\n  return removed\n}\n\n\n\nexport const getDifferences = () => {\n  let  previous = []\n\n  return (array) => {\n    const plus = array.filter(item => previous.indexOf(item) < 0)\n    const minus = previous.filter(item => array.indexOf(item) < 0)\n    previous = [...array]\n\n    return { plus, minus }\n  }\n}\n\n\n\nexport const trackChanges = (array) => {\n  let  previous = [...array]\n\n  return () => {\n    const plus = array.filter(item => previous.indexOf(item) < 0)\n    const minus = previous.filter(item => array.indexOf(item) < 0)\n    previous = [...array]\n\n    return { plus, minus }\n  }\n}\n\n\n\nexport const shuffle = (a) => {\n  let ii = a.length\n\n  while (ii) {\n    const jj = Math.floor(Math.random() * ii)\n    ii -= 1;\n    [a[ii], a[jj]] = [a[jj], a[ii]]\n  }\n\n  return a // for chaining\n}\n\n\n\nexport const getRandom = (max, min = 0) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\n\n\nexport const getRandomFromArray = (array) => {\n  return array[Math.floor(Math.random() * array.length)]\n}\n\n\n\nexport const arrayOverlap = (array1, array2) => {\n  if (!array1 || !array1.length || !array2 || !array2.length) {\n    return []\n  }\n\n  return array1.filter( item => array2.includes(item) )\n}\n\n\n\nexport const getUnused = (source, used, tolerateDuplicates) => {\n  const unused = source.slice(0)\n  used.forEach(item => removeFrom(unused, item))\n  let item = getRandomFromArray(unused)\n\n  if (!item && tolerateDuplicates) {\n    // May return the same item multiple times,\n    // rather than creating a smooth spread\n    item = getRandomFromArray(source)\n  }\n\n  return item\n}\n\n\n\n/// MOUSE/TOUCH EVENT FUNCTIONS ///\n\nexport const getPageXY = (event) => {\n  if (event.targetTouches && event.targetTouches.length) {\n    event = event.targetTouches[0] || {}\n  }\n\n  return { x: event.pageX, y: event.pageY }\n}\n\n\n\nexport const getXY = (event, frame) => {\n  if ([\"client\", \"page\", \"offset\"].indexOf(frame) < 0) {\n    frame = \"client\"\n  }\n  if (event.targetTouches && event.targetTouches.length) {\n    event = event.targetTouches[0] || {}\n  }\n\n  return { x: event[frame + \"X\"], y: event[frame + \"Y\"] }\n}\n\n\n\n/**\n * Returns a promise which will be:\n * * resolved if the mouse or touch moves more than triggerDelta\n *   pixels in any direction\n * * rejected if the mouse is released/touch gesture ends before\n *   moving that far\n *\n * @param  {event}  event should be a mousedown or touchstart event\n * @param  {number} triggerDelta should be a positive number of pixels\n *\n * @return  {promise}\n */\nexport const detectMovement = (event, triggerDelta) => {\n  const trigger2 = triggerDelta * triggerDelta\n\n  function movementDetected(resolve, reject) {\n    const { x: startX, y: startY } = getPageXY(event)\n    const options = { event, drag, drop }\n    const cancel = setTrackedEvents(options)\n    // { actions: { move: <\"touchmove\" | \"mousemove\">\n    //              end:  <\"toucheend\" | \"mouseup\">\n    // , drag: function\n    // , drop: function\n    // }\n\n    // Check if the mouse/touch has moved more than triggerDelta\n    // pixels in any direction, and resolve promise if so.\n    function drag(event) {\n      const { x, y } = getPageXY(event)\n      const deltaX = startX - x\n      const deltaY = startY - y\n      const delta2 = (deltaX * deltaX + deltaY * deltaY)\n\n      if (delta2 > trigger2) {\n        setTrackedEvents(cancel)\n        resolve()\n      }\n    }\n\n    // Reject promise if the mouse is release before the mouse/touch\n    // moved triggerDelta pixels in any direction.\n    function drop(event) {\n      setTrackedEvents(cancel)\n      reject()\n    }\n  }\n\n  return new Promise(movementDetected)\n}\n\n\n\nexport const setTrackedEvents = ({ actions, event, drag, drop }) => {\n  // Omit event to cancel tracking\n  const body = document.body\n\n  if (event) {\n    if (typeof actions !== \"object\") {\n      actions = {}\n    }\n\n    if (event.type === \"touchstart\") {\n      actions.move  = \"touchmove\"\n      actions.end   = \"touchend\"\n    } else {\n      actions.move  = \"mousemove\"\n      actions.end   = \"mouseup\"\n    }\n\n    body.addEventListener(actions.move, drag, false)\n    body.addEventListener(actions.end, drop, false)\n\n  } else {\n    body.removeEventListener(actions.move, drag, false)\n    body.removeEventListener(actions.end, drop, false)\n  }\n\n  return { actions, drag, drop }\n}\n\n\n/// RECT & OBJECT FUNCTIONS ///\n\nexport const intersect = (rect1, rect2) => {\n  return rect1.x < rect2.right\n      && rect2.x < rect1.right\n      && rect1.y < rect2.bottom\n      && rect2.y < rect1.bottom\n}\n\n\n\nexport const intersection = (rect1, rect2) => {\n  const left   = Math.max( rect1.left || rect1.x || 0\n                         , rect2.left || rect2.x || 0\n                         )\n  const right  = Math.min( rect1.right||rect1.left+rect1.width||0\n                         , rect2.right||rect2.left+rect2.width||0\n                         )\n  if (!(left < right)) {\n    return 0\n  }\n\n  const top    = Math.max( rect1.top || rect1.y || 0\n                         , rect2.top || rect2.y || 0\n                         )\n  const bottom = Math.min( rect1.bottom||rect1.top+rect1.height||0\n                         , rect2.bottom||rect2.top+rect2.height||0\n                         )\n  if (!(top < bottom)) {\n    return 0\n  }\n\n  const x = left\n  const y = top\n  const width  = right - x\n  const height = bottom - y\n\n  return { x, y, left, right, top, bottom, width, height }\n}\n\n\n\nexport const union = (rects) => {\n  const [ rect, ...rest ] = rects\n  let { left, right, top, bottom } = rect\n\n  rest.forEach( rect => {\n    left   = Math.min(left,   rect.left)\n    right  = Math.max(right,  rect.right)\n    top    = Math.min(top,    rect.top)\n    bottom = Math.max(bottom, rect.bottom)\n  })\n\n  const x = left\n  const y = top\n  const width = right - left\n  const height = bottom - top\n\n  return { x, y, left, right, top, bottom, width, height }\n}\n\n\n\nexport const pointWithin = ( x, y, rect ) => {\n  return rect.x <= x\n      && rect.y <= y\n      && rect.right > x\n      && rect.bottom > y\n}\n\n\n/**\n * Calculates which fraction of rect shares it area with container\n */\nexport const overlap = (rect, container) => {\n  let overlap = intersection(rect, container) // 0 or rect object\n\n  if (overlap) {\n    const width  = rect.width || (rect.left - rect.right)\n    const height = rect.height || (rect.bottom - rect.top)\n    overlap = (overlap.width * overlap.height) / (width * height)\n  }\n\n  return overlap\n}\n\n\n\nexport const valuesMatch = (a, b) => {\n  if ( !a || typeof a !== \"object\" || !b || typeof b !== \"object\") {\n    return false\n  }\n\n  const propsA = Object.getOwnPropertyNames(a)\n  const propsB = Object.getOwnPropertyNames(b)\n\n  if (propsA.length !== propsB.length) {\n    return false\n  }\n\n  const total = propsA.length\n  for ( let ii = 0; ii < total; ii += 1 ) {\n    const prop = propsA[ii]\n\n    if (a[prop] !== b[prop]) {\n      return false\n    }\n\n    if (!removeFrom(propsB, prop)) {\n      // prop is undefined in a and missing in b\n      return false\n    }\n  }\n\n  return true\n}\n\n\n\nexport const valuesDontMatch = (a, b) => {\n  const nonMatching = {}\n\n  if ( !a || typeof a !== \"object\" || !b || typeof b !== \"object\") {\n    return { a, b }\n  }\n\n  const propsA = Object.getOwnPropertyNames(a)\n  const propsB = Object.getOwnPropertyNames(b)\n\n  propsA.forEach(prop => {\n    if (propsB.indexOf(prop) < 0) {\n      nonMatching[prop] = [\"delete\", a[prop]]\n\n    } else {\n      removeFrom(propsB, prop)\n\n      const valueA = a[prop]\n      const valueB = b[prop]\n\n      // if (path) {\n      //   prop = path + \".\"+ prop\n      // }\n\n      if (typeof valueA === \"object\" && typeof valueB === \"object\") {\n        const nested = valuesDontMatch(valueA, valueB)\n        if (nested) {\n          nonMatching[prop] = nested\n        }\n\n      } else if (valueA !== valueB) {\n        nonMatching[prop] = [\n          \"change\"\n       , getString(valueA)\n       , getString(valueB)\n       ]\n      }\n    }\n  })\n\n  propsB.forEach(prop => {\n    if (propsA.indexOf(prop) < 0) {\n      // if (path) {\n      //   prop = path + \".\"+ prop\n      // }\n\n      nonMatching[prop] = [\"insert\", getString(b[prop])]\n    }\n  })\n\n  if (Object.keys(nonMatching).length) {\n    return nonMatching\n  }\n}\n\n\n\nexport const deleteFrom = (object, key, removed) => {\n  if (typeof removed !== \"object\") {\n    removed = {}\n  }\n\n  // If `key` is an array of keys, treat recursively\n  if (Array.isArray(key)) {\n    key.forEach( entry => deleteFrom(object, entry, removed) )\n    return removed\n\n  } else if (key === undefined) {\n    key = (key, value) => (value === undefined || value === null)\n  }\n\n  // If we get here, key is an individual item\n  if (typeof key === \"function\") {\n    const keys = Object.keys(object)\n    keys.forEach( property => {\n      const value = object[property]\n      const deleteIt = key(property, value)\n      if (deleteIt) {\n        removed[property] = value\n        delete object[property]\n      }\n    })\n\n  } else if (object.hasOwnProperty(key)) {\n    removed[key] = object[key]\n    delete object[key]\n  }\n\n  return removed\n}\n\n\n// FONTS //\n\nexport const getFontFamily = (ff) => {\n  const start = ff.indexOf('family=')\n  if (start === -1) return 'sans-serif'\n  let end = ff.indexOf('&', start)\n  if(end === -1) end = undefined\n  ff = ff.slice(start + 7, end).replace(\"+\", \" \")\n  ff = '\"'+ ff + '\"'\n  return ff // + ', sans-serif'\n}\n\n\n// ENCRYPTION\n\n// by bryc https://stackoverflow.com/a/52171480/1927589\n//\n// WARNING\n// VS Code considers that lines like ...\n//\n//   h1 ^ h1>>>16 \n//\n// ... include an \"unexpected mix\" of operators\nexport const hash = (str, seed = 0) => {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\n  for (let i = 0, ch; i < str.length; i++) {\n      ch = str.charCodeAt(i)\n      h1 = Math.imul(h1 ^ ch, 2654435761)\n      h2 = Math.imul(h2 ^ ch, 1597334677)\n  }\n  h1 = Math.imul(h1 ^ h1>>>16, 2246822507)\n     ^ Math.imul(h2 ^ h2>>>13, 3266489909)\n  h2 = Math.imul(h2 ^ h2>>>16, 2246822507)\n     ^ Math.imul(h1 ^ h1>>>13, 3266489909)\n\n  return 4294967296 * (2097151 & h2) + (h1>>>0)\n}\n\n\n// IMAGES //\n\n// Inspired by https://ourcodeworld.com/articles/read/683/how-to-remove-the-transparent-pixels-that-surrounds-a-canvas-in-javascript\n// MIT http://rem.mit-license.org\nexport const trimImage = (image) => {\n  const c = document.createElement(\"canvas\")\n  c.width = image.width\n  c.height = image.height\n\n  const ctx = c.getContext('2d')\n  ctx.drawImage(image, 0, 0)\n\n  const copy = document.createElement('canvas').getContext('2d')\n  const pixels = ctx.getImageData(0, 0, c.width, c.height)\n  const l = pixels.data.length\n  const bound = {\n    top: null\n  , left: null\n  , right: null\n  , bottom: null\n  }\n  let ii\n    , x\n    , y\n\n  // Iterate over every pixel to find the highest\n  // and where it ends on every axis ()\n  for (ii = 0; ii < l; ii += 4) {\n      if (pixels.data[ii + 3] !== 0) {\n          x = (ii / 4) % c.width\n          y = ~~((ii / 4) / c.width)\n\n          if (bound.top === null) {\n              bound.top = y\n          }\n\n          if (bound.left === null) {\n              bound.left = x\n          } else if (x < bound.left) {\n              bound.left = x\n          }\n\n          if (bound.right === null) {\n              bound.right = x\n          } else if (bound.right < x) {\n              bound.right = x\n          }\n\n          if (bound.bottom === null) {\n              bound.bottom = y\n          } else if (bound.bottom < y) {\n              bound.bottom = y\n          }\n      }\n  }\n\n  // Calculate the height and width of the content\n  const trimHeight = bound.bottom - bound.top\n  const trimWidth = bound.right - bound.left\n  const trimmed = ctx.getImageData(\n    bound.left\n  , bound.top\n  , trimWidth\n  , trimHeight\n  )\n\n  // console.log(bound)\n\n  copy.canvas.width = trimWidth\n  copy.canvas.height = trimHeight\n  copy.putImageData(trimmed, 0, 0)\n\n  // Return an image\n  const trimmedImage = new Image()\n  trimmedImage.src =copy.canvas.toDataURL()\n\n  return trimmedImage\n}\n//\n// window.trimImage = trimImage\n\n\n\n// STRINGS //\n\n/** Adds customizable inserts to a string (e.g. Welcome <username>)\n *\n * @param      {string}  phrase   string OR\n *                                { simple:  \"Log in\"\n *                                , replace: \"Log in as ^0\"\n *                                }\n * @param     {object}   options  { \"^0\": \"admin\", ... }\n *\n * @return    {string}   string (with customized inserts)\n */\nexport const substitute = (phrase, options) => {\n  if (options && typeof options === \"object\") {\n    if (typeof phrase === \"object\") {\n      phrase = phrase.replace\n    }\n\n    for (let key in options) {\n      phrase = phrase.replace(key, options[key])\n    }\n\n  } else if (typeof phrase === \"object\") {\n    phrase = phrase.simple\n  }\n\n  // Replace underscores with non-breaking spaces\n  phrase = phrase.replace(/_/g, \" \")\n\n  return phrase\n}\n\n\n/**\n * Returns the best localized string from a map of phrases\n *\n * @param   {object}  phraseData   { ...\n *                                 , \"co-DE\": \"regional string\"\n *                                 , \"co\": \"generic string\"\n *                                 , \"xx\": {\n *                                     simple:  \"Log in\"\n *                                   , replace: \"Log in as ^0\"\n *                                   }\n *                                 , \"zz\": \"String with ^0 to replace\"\n *                                 , ...\n *                                 }\n * @param   {string}  code         language code ≈ \"co\" or \"co-DE\"\n * @param   {object}  options      { \"^0\": \"admin\", ... }\n *                                 OR\n *                                 \"as_is\", in which case any object\n *                                 containing simple and replace\n *                                 strings will be returned as an\n *                                 object\n *                                 OR\n *                                 other values are ignored\n *\n * @return  {string}  \"<Missing>\" or the localized string\n */\nexport const getLocalized = (phraseData, code = \"en\", options) => {\n  let phrase = phraseData[code]\n\n  if (!phrase) {\n    // Check if there is a more generic phrase without the region\n    const stripRegex = /-\\w+/\n    code = code.replace(stripRegex, \"\") // \"co-DE\" => \"co\"\n    phrase = phraseData[code]\n\n    if (!phrase) {\n      // Use any regional dialect of English as a fallback\n      const available = Object.keys(phraseData)\n      code = available.find(key => key.replace(stripRegex) === \"en\")\n\n      if (code) {\n        phrase = phraseData[code]\n      } else {\n        // Use the first available language\n        phrase = phraseData[available[0]]\n      }\n\n      if (!phrase) {\n        phrase = \"<Missing>\"\n      }\n    }\n  }\n\n  if (options !== \"as_is\") {\n    phrase = substitute(phrase, options)\n  }\n\n  return phrase\n}\n\n\n/** Selects a localized string from an array and customizes it\n *  replacing any (visible) underscores with (invisible)\n *  non-breaking spaces\n *\n * @param      {string}  cue     string cue value from corpus\n * @param      {string}  code    string language code, like \"co-DE\"\n * @param      {array}   corpus  [ { \"cue\": \"unique_string\"\n *                                 , \"co-DE\": \"fixed string\"\n *                                 , \"co\":    \"variable string ^0\"\n *                                 , ...\n *                                 }\n *                               , ...\n *                               ]\n * @param     {object}   options  { \"^0\": \"changeable part\", ...}\n *\n * @return    {string}   '***cue***' or localized string with &nbsp;\n */\nexport const localize = (cue, code, corpus, options) => {\n  let phrase\n\n  const phraseData = corpus.find(phrase => (\n    phrase.cue === cue\n  ))\n\n  if (phraseData) {\n    phrase = getLocalized(phraseData, code, options)\n  }\n\n  if (!phrase) {\n    console.log( \"Not found — cue:\", cue\n               , \"code:\", code\n               , \"phraseData:\", phraseData\n               )\n    phrase = \"***\" + cue + \"***\"\n  }\n\n  return phrase\n}\n\n\nexport const getString = item => {\n  const type = typeof item\n  try {\n    switch (type) {\n      case \"undefined\":\n        return \"undefined\"\n      case \"string\":\n      case \"object\":\n        return item\n      default:\n        if (item.toString) {\n          return item.toString()\n        } else {\n          return item\n        }\n    }\n  } catch {\n    return \"Unable to convert \" + type + \": \" + item\n  }\n}\n\n\n// HTML ELEMENTS //\n\n\n/** Returns index of the child of parentTag that contains element\n *\n * This is useful when you want to find (for instance) which list\n * item was selected, given that the event occurred on a child of the\n * list item.\n *\n * @param    {<type>}          element    An HTML element\n * @param    {string}          parentTag  The string tag of the parent\n *                                        of the element that contains\n *                                        `element`. \"UL\" by default.\n * @return   {integer}  -1 if element is not valid or if it does not\n *                      have a parent with the given tag, Non-negative\n *                      integer if the element's parent is found.\n */\nexport const getElementIndex = (element, parentTag) => {\n  let index = -1\n\n  if (element instanceof HTMLElement) {\n    parentTag = typeof parentTag === \"string\"\n              ? parentTag.toUpperCase()\n              : \"UL\"\n\n    while (element && element.parentNode.tagName !== parentTag) {\n      element = element.parentNode\n    }\n\n    if (element) {\n      const siblings = [].slice.call(element.parentNode.children)\n      index = siblings.indexOf(element)\n    }\n  }\n\n  return index\n}\n","/**\n * /src/components/Pocket.jsx\n */\n\n\nimport { getCards } from '../api/pairs'\nimport Card from './Card'\n\nconst Pocket = (props) => {\n  const { phoneme, index, audio, playAudio, played } = props\n\n\n  const getCard = ( card, index ) => {\n    return (\n      <Card \n        card={card}\n      />\n    )\n  }\n\n\n  const getCardList = () => {\n    const listOfCards = played.map(getCard)\n    return (\n      <ul>\n        {listOfCards}\n      </ul>\n    )\n  }\n\n\n  const cardList = getCardList()\n  const className = `phoneme-${index + 1}`\n\n\n  return (\n    <div className={className}>\n      {cardList}\n      <div className=\"pocket\"></div>\n      <button \n        className=\"play-phoneme\"\n        onClick={() => playAudio(audio)}\n      >\n        /{phoneme}/\n      </button>\n    </div>\n  )\n}\n\nexport default Pocket\n\n\n\n// <div className=\"phoneme-1\">\n//   <ul>\n//     {/* OLDER CARDS CAN GO HERE */}\n//     <li>\n//       <div className=\"card\">\n//         <img src=\"img/ɪ/bitch.jpg\" alt=\"bitch\" />\n//         <p className=\"phonetic\">/bɪʧ/</p>\n//         <p className=\"spelling\">bitch</p>\n//       </div>\n//     </li>\n//   </ul>\n//   {/* POCKET */}\n//   <div className=\"pocket\"></div>\n//   <button className=\"play-phoneme\">ɪ</button>\n// </div> */}","import React, { Component } from 'react'\n\nimport './App.css';\nimport AudioElement from './Audio'\nimport Card from './Card'\nimport Pocket from './Pocket'\n\nimport { getCards } from '../api/pairs'\nconst AUDIO_URL = \"/pairs.mp3\"\n\nclass App extends Component{\n  useFirstCard = true\n\n  constructor(props) {\n    super(props)\n\n    this.playAudio = this.playAudio.bind(this)\n    this.state = getCards() // imported from pairs.js\n\n    console.log(\"this.state:\", this.state)\n    // { \"phonemes\": [\n    //     { phoneme: \"ɪ\", audio: [0, 1]\n    //   , { phoneme: \"iː\", audio: [10, 11]\n    //   ],\n    //   \"word1\": {\n    //     \"spelling\": \"ship\",\n    //     \"phonetic\": \"/∫ɪp/\",\n    //     \"image\": \"img/ship.jpg\",\n    //     \"audio\": [\n    //       0,\n    //       1\n    //     ]\n    //   },\n    //   \"word2\": {\n    //     \"spelling\": \"sheep\",\n    //     \"phonetic\": \"/∫iːp/\",\n    //     \"image\": \"img/sheep.jpg\",\n    //     \"audio\": [\n    //       0,\n    //       1\n    //     ]\n    //   },\n    //   \"played\" {\n    //     \"ɪ\": [<card>, ...],\n    //     \"iː\": [<card>, ...]\n    //   }\n    // }\n  }\n\n  playAudio(audio) {\n    console.log(\"playAudio:\", audio)\n  }\n\n  getCards() {\n    const useFirstCard = Math.floor(Math.random() * 2 )\n\n    let cards\n    if (useFirstCard) {\n      cards = [ this.state.word1, this.state.word2 ]\n    } else {\n      cards = [ this.state.word2, this.state.word1 ]\n    }\n\n    let roles = [\"decoy\", \"cue\"].map((role, index) => {\n      const card = cards[index]\n\n      return (\n        <Card \n          card={card}\n          role={role}\n          taboo={true}\n        />\n      )\n    })\n\n    return roles\n  }\n\n\n  getPockets() {\n    // cards, index, phoneme, audio, playAudio\n    const pockets = this.state.phonemes.map((phonemeData, index) => {\n      const { phoneme, audio } = phonemeData\n      const played = this.state.played[phoneme]\n      const playAudio = this.playAudio\n\n      return <Pocket\n        phoneme={phoneme}\n        index={index}\n        audio={audio}\n        playAudio={this.playAudio}\n        played={played}\n      />\n    })\n\n    return pockets\n  }\n\n\n  render() {\n    const [ card1, card2 ]  = this.getCards()\n    const [ pocket1, pocket2 ] = this.getPockets()\n\n    return <main className=\"split\">\n      <div className=\"phonemes\">\n        {pocket1}\n        {pocket2}\n        <p className=\"rule\">Tap or drag to here</p>\n      </div>\n\n      <div className=\"pairs\">\n        {card1}\n        {card2}\n      </div>\n    </main>\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
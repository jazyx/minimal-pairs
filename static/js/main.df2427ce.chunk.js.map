{"version":3,"sources":["components/AudioContext.jsx","components/About.jsx","components/Card.jsx","components/CardAndPocket.jsx","tools/utilities.js","api/pairs.js","components/Activity.jsx","components/App.jsx","components/Contact.jsx","components/Index.jsx","tools/storage.js","components/Preferences.jsx","api/views.js","components/Splash.jsx","components/MenuIcon.jsx","components/FullScreen.jsx","components/MenuItems.jsx","components/Menu.jsx","reportWebVitals.js","index.js"],"names":["AudioContext","createContext","AudioProvider","timeOut","children","audio","Audio","playing","Provider","_stopAudioPlayback","pause","value","playClip","url","clip","startTime","duration","src","currentTime","clearTimeout","setTimeout","play","then","result","catch","error","console","log","_startAudioPlayback","About","startActivity","id","className","onClick","Card","forwardRef","props","cardRef","card","spelling","phonetic","image","image_","role","spaceName","taboo","useContext","action","ref","onMouseDown","onTouchStart","alt","CardAndPocket","pocketRef","index","cardData","phonemeData","played","cueAction","pocketAction","phoneme","listOfCards","map","key","removeFrom","array","item","removeAll","found","removed","Array","isArray","reduce","excess","entry","findIndex","indexOf","splice","getPageXY","event","targetTouches","length","x","pageX","y","pageY","detectMovement","triggerDelta","trigger2","isNaN","Math","abs","Promise","resolve","reject","startX","startY","options","drag","deltaX","deltaY","cancelDrag","drop","startTracking","defaultDragAction","selector","rider","offset","target","closest","element","parent","tagName","parentNode","getComputedStyle","getPropertyValue","getNonStaticParent","getBoundingClientRect","fixLeft","left","fixTop","top","style","noDefault","preventDefault","move","end","body","document","type","removeEventListener","addEventListener","passive","currentPair","pairList","phonemeSymbols","phonemes","word1","word2","pointWithin","rect","right","bottom","pairs","require","AUDIO_DIR","phonemePairs","Object","keys","pairIndex","setPhonemePair","pair","entries","getPhonemeData","a","ii","jj","floor","random","shuffle","_setPairListAndPhonemeSymbols","undefined","getWordData","word","words","data","mainElement","getBoolean","lastFourValues","randomBoolean","hint","max","min","output","accumulator","shift","push","getBooleanGenerator","PLAY_DELAY","Activity","cueURL","cueClip","cueSpace","cueCard","decoyURL","decoyClip","decoySpace","decoyCard","phoneme0","phoneme1","mask","pockets","cueRect","decoyRect","visibleCard","cueRef","useRef","decoyRef","phoneme0Ref","phoneme1Ref","maskRef","useState","counter","setCounter","phoneme2","cards","getCards","playedCards","wrong","inProgress","playCue","showWrong","classList","remove","add","showNextCard","hideOtherCard","playOtherCard","showOtherCard","moveIntoPocket","moveNearToPocket","playRightSequence","proceedToNextCard","unspreadCards","from","querySelectorAll","forEach","cardTopLeft","pageLoc","pocket","checkForDrag","contains","transitionDuration","cuePocket","querySelector","decoyPocket","startDrag","list","parseInt","exec","pocketCard","prepareToSpreadCards","reason","playFromPocket","spreadCards","showCardOutsidePocket","cardIndex","phonemeIndex","showCardsOutsidePocket","useSecondCard","createPockets","pocket1","pocket2","useEffect","current","Contact","Index","getSelectButton","itemClicked","pairsArray","progress","select","pairData","phonemeButtons","wordButtons","wordData","getPhonemeButton","set","getWordButton","width","CustomStorage","this","storage","stored","window","localStorage","settings","JSON","parse","getItem","_save","assign","defaultValues","string","stringify","setItem","store","get","leftHanded","split","showCue","showPhonetic","Views","Preferences","classNameIsSet","toggleClassName","setLeftHanded","setSplit","setShowCue","setShowPhonetic","htmlFor","defaultChecked","onChange","newValue","Splash","Icon","d","opacity","FullScreenButton","toggleFullScreen","docElm","documentElement","requestFullscreen","mozRequestFullScreen","webkitRequestFullScreen","msRequestFullscreen","exitFullscreen","mozCancelFullScreen","webkitCancelFullScreen","msExitFullscreen","component","isIOS","test","navigator","userAgent","isAppleDevice","includes","isTouchScreen","maxTouchPoints","volume","iosQuirkPresent","xmlns","viewBox","onMouseUp","height","stroke","strokeWidth","asListItem","MenuItems","itemSelected","Items","closeMenu","selectFromMenu","pane","Menu","React","createRef","callback","openMenu","bind","state","open","ignoreOpen","toggleMenu","listener","timeout","menu_open","setState","itemClass","preserveAspectRatio","Component","App","view","setView","mainRef","newView","View","on","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","getElementById","scrollTo"],"mappings":"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","file":"static/js/main.df2427ce.chunk.js","sourcesContent":["/**\n * src/components/AudioContext\n *\n * An audio clip is defined as a file path and a begin and end point in\n * that file. measured in seconds. For example:\n *\n * { url: \"audio/ɑ.mp3\"\n * , \"clip\": [2.450, 3.550]\n * }\n *\n * For any minimal pair, there will be two audio clips, for example: for\n * \"staff\" and for \"stuff\". Each of these will be stored in a separate\n * file, with a separate url. Switching from one recording to the other\n * will mean loading a different audio file.\n */\n\nimport React, { createContext } from 'react'\n\nexport const AudioContext = createContext()\n\nexport const AudioProvider = ({ children }) => {\n  // eslint-disable-next-line\n  const audio = new Audio()\n  let playing = false // will temporarily become truthy relative path\n  let timeOut\n\n  const Provider = AudioContext.Provider\n\n  const _stopAudioPlayback = () => {\n    audio.pause()\n    playing = false\n  }\n\n  const _startAudioPlayback = (url, clip) => {\n    if (url === playing) {\n      return // Let this sound play to the end\n    }\n\n    if (playing) { // Replace playing sound with the new one\n      _stopAudioPlayback()\n    }\n\n    const [ startTime, endTime ] = clip\n    const duration = (endTime - startTime) * 1000 // ms\n\n    audio.src = url\n    audio.currentTime = startTime                  // s\n    clearTimeout(timeOut)\n    timeOut = setTimeout(_stopAudioPlayback, duration)\n\n    audio.play()\n         .then(result => {\n          playing = url\n         }).catch(error => {\n           console.log(\"Audio.play() error:)\", error)\n         })\n  }\n\n  const playClip = (url, clip) => {\n    // TODO: Fade out current audio playback before\n    // starting to play new clip.\n    _startAudioPlayback(url, clip)\n  }\n\n  return (\n    <Provider\n      value = {{\n        playClip\n      }}\n    >\n      {children}\n    </Provider>\n  )\n}","/**\n * /src/components/About.jsx\n */\n\n\nimport React from 'react';\nimport './About.css'\n\n\nconst About = ({ startActivity }) => {\n  return (\n    <div id=\"about\">\n      <h1>Minimal Pairs</h1>\n      <p>A minimal pair is a set of two words whose sounds differ by only one phoneme.<br/>For example: \"stuff\" and \"staff\".</p>\n\n      <p>When you are learning English as a foreign language, you may have difficulty hearing minor differences which are important in your target language but not in your native language.</p>\n\n      <p>This app helps you to recognize the differences.</p>\n\n      <p>You will see a picture and hear a spoken word. You will also see two  symbols that represent a phonetic sound. Choose which sound you heard in the spoken word. Repeat until you can hear the difference between the two sounds easily.</p>\n\n      <p>You can use the menu in the top corner to choose other pairs of sounds, or to set your preferences.</p>\n      <button\n        className=\"continue\"\n        onClick={startActivity}\n      >\n        Continue\n      </button>\n    </div>\n  )\n}\n\n\nexport default About","/**\n * /src/components/Card.jsx\n */\n\n\nimport React, { useContext, forwardRef } from 'react'\nimport { AudioContext } from './AudioContext'\n\n\nconst Card = forwardRef((props, cardRef) => {\n  // console.log(\"card:\", props.card)\n  const {\n    spelling\n  , phonetic\n  , clip\n  , url\n  , image\n  , image_\n  } = props.card\n\n  const className = \"card\"\n                  + ( props.role\n                    ? \" flipped\"\n                    : \"\"\n                    )\n  const spaceName = \"card-holder\"\n                  + ( props.role\n                    ? \" space\"\n                    : \"\"\n                    )\n  const src = props.taboo ? (image_ || image) : image\n  const audio = useContext(AudioContext)\n  const action = props.action // will be undefined for decoy\n              || (() => audio.playClip(url, clip)) // only for decoy\n\n  return (\n    <div\n      className={spaceName}\n      ref={cardRef}\n    >\n      <div\n        className={className}\n        key={spelling}\n        onMouseDown={action}\n        onTouchStart={props.action}\n      >\n        <img\n          className=\"back unselectable\"\n          src=\"img/icons/sound.svg\"\n          alt=\"play audio icon\"\n        />\n        <div className=\"front unselectable\">\n          <img src={src} alt={spelling}/>\n          <p className=\"phonetic\">{phonetic}</p>\n          <p className=\"spelling\">{spelling}</p>\n        </div>\n      </div>\n    </div>\n  )\n})\n\n\nexport default Card","/**\n * /src/components/CardAndPocket.jsx\n *\n * This script creates a component which contains:\n *\n * - An unordered list of previously seen cards\n * - A two-sided card, whose z-index may change\n * - A \"pocket\" for the card and lists to be placed behind\n *\n * Stacking\n * --------\n * Each of these components will be absolutely placed, so that their\n * internal elements will belong to the same stacking context. The\n * container <div> will not be positioned, so co-ordinates will be\n * determined with respect to the <main> parent element. There will be\n * two CardAndPocket components, one for the decoy card and one for the\n * cue card. The stacking will be as follows:\n *\n * <main (positioned by flex)>\n *   <div (not positioned)>\n *     <decoy list />\n *     <decoy card />\n *     <decoy pocket />\n *   </div>\n *   <div (not positioned>\n *     <cue list />\n *     <cue card />\n *     <cue pocket />\n *       (cue card when z-index is 1)\n *   </div>\n * </main>\n *\n *\n * Pocket\n * ------\n * The pocket will have a phonetic symbol on it, and a button with a\n * Play Audio icon. If you press this button, you will hear a recording\n * of the phonetic sound.\n *\n * Card\n * ----\n * The card will initially be displayed facing down. The Play Audio\n * symbol will appear on its back. On the front of the card will be\n * shown:\n * - A word\n * - A phonetic transcription of the word\n * - An image illustrating the word\n *\n * Pressing on the card (on either side) will play a recording of the\n * word.\n *\n * Previous Cards\n * --------------\n * The most recent card will be partly visible in the pocket. The\n * earlier cards will be hidden behind it.\n *\n * Clicking on the visible part of the top card will:\n * • Block any other mouse interactions\n * • Slide the card out of the pocket\n * • Play the audio associated with the card\n * • Slide the card back in\n * • Restore other mouse interactions.\n *\n * Clicking-and-holding on the visible part of the top card, or\n * dragging the card in any direction, will:\n * • Block default other mouse interactions\n * • Slide both lists of cards out of the pocket in two ribbon spreads\n * • Show a > button, which will return the cards to their pockets and *   restore other mouse interactions\n * • Wait for the user to click on a card\n *\n *\n *\n * INTERACTIONS\n * ============\n * Interactions are controlled by the Activity.jsx script.\n *\n * Card Interactions\n * -----------------\n * The card may represent either a cue or a decoy. Another instance of\n * this component will create a matching decoy/cue Card and Pocket pair.\n *\n * If it is a cue, its audio recording will be played automatically.\n * If the user then either presses the matching pocket or drags the\n * card to the pocket, a Success Sequence will play:\n *\n * 1. The card will be placed over the pocket (z-index > 0)\n * 2. Its audio recording will play\n * 3. It will slide to the edge of the pocket...\n * 4. ... lose its z-index ...\n * 5. ... and slide in behind the pocket\n *\n * There are 3 preference settings to determine what happens next.\n * 1. By default, the associated decoy card will flip over, play its\n *    audio, then slide behind the other pocket\n * 2. If Play Similar Word is not checked, the associated decoy card\n *    will simply turn over and slide behind the other pocket\n * 3. If Compare With Similar Word is not checked, the associated decoy\n *    card will not even be shown.\n *\n * Interactions with Previous Cards\n * --------------------------------\n * A simple press on the visible part of a previous card will play its\n * word, so you can compare the words from the top card in each pocket.\n *\n * A prolonged press or a drag on a previous card will spread the cards\n * over the window:\n *\n * 1. All cards will be moved together to the far end,\n * 2. All cards from both pockets will be spread back towards the\n *    pocket, so that the top card in each set is over the pocket (just\n *    where it was when it was correctly played). It will not overlap\n *    any other card. The other cards will overlap equally, if there is\n *    not enough space for them to appear separately.\n * 3. Clicking on a wholly visible card will play its audio, and then\n *    the audio of the matching card in the other set\n * 4. Clicking on the visible part of a card which is overlapped will\n *    adjust the position of the other cards so that the clicked card\n *    is fully visible, and the cards either side are partly visible\n *    where other cards do not overlap them.\n *\n * At the place where the text \"Tap or drag to here\" is shown, a button\n * labelled \"Done\" will appear. Clicking on this will move all the\n * previously viewed cards into two piles at the edge of their\n * respective pockets, and then slide them in.\n */\n\nimport React, { useContext, forwardRef } from 'react'\nimport { AudioContext } from './AudioContext'\n\nimport Card from './Card'\n\nconst CardAndPocket = forwardRef((props, pocketRef) => {\n  const audio = useContext(AudioContext)\n  const {\n    index        // 0 | 1\n  , cardData     // { spelling, phonetic, image, url, clip }\n  , phonemeData  // { phoneme, url, clip }\n  , role         // cue    | decoy\n  , cardRef      // cueRef | decoyRef\n  , played       // [ <card object>, ... ]\n  , cueAction    // Activity.checkForDrag, for cue card\n  , pocketAction //\n  } = props\n\n  const {\n    phoneme\n  , url\n  , clip\n  } = phonemeData\n\n  const card = (\n    <Card\n      card={cardData}\n      role={role}\n      ref={cardRef}\n      action={cueAction}\n    />\n  );\n\n  const getCard = ( card ) => {\n    const key = card.spelling\n    return (\n      <li\n        key={key}\n      >\n        <Card\n          card={card}\n          action={pocketAction}\n        />\n      </li>\n    )\n  }\n\n  const listOfCards = played.map(getCard)\n\n  const className = `phoneme-${index} ${role}`\n\n  return (\n    <div\n      className={className}\n      ref={pocketRef}\n    >\n      <ul>\n        {listOfCards}\n      </ul>\n\n      {card} {/* initially with z-index > 0 to appear above pocket */}\n\n      <div\n        className=\"pocket unselectable\"\n      >\n        /{phoneme}/\n\n        <button\n          className=\"play-phoneme\"\n          onClick={() => audio.playClip(url, clip)}\n        />\n      </div>\n    </div>\n   )\n})\n\nexport default CardAndPocket","/**\n * /imports/tools/generic/utilities.js\n *\n * Provides a set of re-usable functions which can be imported\n * anywhere\n */\n\n/// COLOR FUNCTIONS //\n\nexport const rgbify = (color) => {\n  if (color.substring(0, 3).toLowerCase() === \"hsl\") {\n    return HSLtoRGB(color);\n  }\n\n  if (color[0] === \"#\") {\n    color = color.slice(1);\n  }\n\n  if (color.length === 3) {\n    color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\n  }\n\n  const hex = parseInt(color, 16);\n\n  return [\n    hex >> 16, // red\n    (hex >> 8) & 0x00ff, // green\n    hex & 0xff, // blue\n  ];\n};\n\nexport const tweenColor = (color1, color2, ratio) => {\n  const rgb1 = rgbify(color1);\n  const rgb2 = rgbify(color2);\n\n  const hex = rgb1.map((value, index) => {\n    value = Math.round(value - (value - rgb2[index]) * ratio);\n    value = Math.max(0, Math.min(value, 255));\n\n    return (value < 16 ? \"0\" : \"\") + value.toString(16);\n  });\n\n  return \"#\" + hex.join(\"\");\n};\n\nexport const toneColor = (color, ratio) => {\n  const prefix = color[0] === \"#\";\n\n  if (prefix) {\n    color = color.slice(1);\n  }\n\n  const rgb = rgbify(color).map((value) => {\n    value = Math.floor(Math.max(0, Math.min(255, value * ratio)));\n    return (value < 16 ? \"0\" : \"\") + value.toString(16);\n  });\n\n  return (prefix ? \"#\" : \"\") + rgb.join(\"\");\n};\n\nexport const translucify = (color, opacity) => {\n  if (color[0] === \"#\") {\n    color = color.slice(1);\n  }\n\n  const rgb = rgbify(color);\n\n  return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;\n};\n\n// https://stackoverflow.com/a/20129594/1927589\n// https://qph.fs.quoracdn.net/main-qimg-aaa9a544d797f1109b29c55814319195.webp\nexport const getColor = ({ number, s = 0.5, l = 0.33, format = \"hsl\" }) => {\n  const h = number * 137.50776405; // ≈ golden angle: 180*(3-√5)\n\n  s = Math.max(0, Math.min(s, 1));\n  l = Math.max(0, Math.min(l, 1));\n\n  switch (format.toLowerCase()) {\n    case \"rgb\":\n      return hsl2rgb(h, s, l);\n\n    case \"hex\":\n      return hsl2hex(h, s * 100, l * 100);\n\n    default:\n      // \"hsl\"\n      return `hsl(${h},${s * 100}%,${l * 100}%)`;\n  }\n};\n\n// https://stackoverflow.com/a/54014428/1927589\n// input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,1]\nexport const hsl2rgb = (h, s, l) => {\n  let a = s * Math.min(l, 1 - l);\n  let f = (n, k = (n + h / 30) % 12) =>\n    l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n};\n\n// https://stackoverflow.com/a/44134328/1927589\nexport const hsl2hex = (h, s, l) => {\n  h /= 360;\n  s /= 100;\n  l /= 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    const hue2rgb = (p, q, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  const toHex = (x) => {\n    const hex = Math.round(x * 255).toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n  };\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\nexport const HSLtoRGB = (colorString) => {\n  // \"hsl(412.523,50%,40%)\" <<< percentages\n  // \"412.523, 0.5, 0.4\"    <<< ratios\n  let rgb = [0, 0, 0];\n\n  const regex =\n    /(hsl\\s*\\(\\s*)?([0-9.]+)\\s*,\\s*([0-9.]+)(%?)\\s*,\\s*([0-9.]+)(%?)\\s*\\)?/;\n  const match = regex.exec(colorString);\n\n  if (match) {\n    let h = parseFloat(match[2], 10);\n    let s = parseFloat(match[3], 10);\n    let l = parseFloat(match[5], 10);\n\n    while (h > 360) {\n      h -= 360;\n    }\n    while (h < 0) {\n      h += 360;\n    }\n    if (match[4]) {\n      s /= 100;\n    }\n    s = Math.max(0, Math.min(s, 1));\n    if (match[6]) {\n      l /= 100;\n    }\n    l = Math.max(0, Math.min(l, 1));\n\n    rgb = hsl2rgb(h, s, l) // [<0.0-1.0>, <0.0-1.0>, <0.0-1.0>]\n      .map((number) => Math.round(number * 255));\n  }\n\n  return rgb;\n};\n\n/**\n * @param   {<type>}  color   Must be a color (rgb or hex)\n * @param   {object}  values  May be an object with the same\n *                            structure as defaults\n * @return  {object}  Returns an object with the same structure as\n *                    defaults, but where each value is a color\n */\nexport const buttonColors = (color, values) => {\n  const output = {\n    restBg: 1,\n    restTint: 1.5,\n    restShade: 0.75,\n\n    overBg: 1.1,\n    overTint: 1.65,\n    overShade: 0.667,\n\n    downBg: 0.95,\n    downTint: 1.333,\n    downShade: 0.6,\n  };\n  const keys = Object.keys(output);\n\n  (function merge(input) {\n    if (typeof input === \"object\") {\n      keys.forEach((key) => {\n        const value = input[key];\n        if (!isNaN(value)) {\n          if (value > 0) {\n            output[key] = value;\n          }\n        }\n      });\n    }\n  })();\n\n  keys.forEach((key) => (output[key] = toneColor(color, output[key])));\n\n  return output;\n};\n\n/// ARRAY FUNCTIONS ///\n\nexport const removeFrom = (array, item, removeAll) => {\n  let removed = 0;\n\n  // If `item` is an array of items or functions, treat recursively\n  if (Array.isArray(item)) {\n    removed = item.reduce((excess, entry) => {\n      excess += removeFrom(array, entry, removeAll);\n      return excess;\n    }, 0);\n\n    return removed;\n  }\n\n  // If we get here, item is an individual items or function\n  let index, found;\n\n  do {\n    if (typeof item === \"function\") {\n      index = array.findIndex(item);\n    } else {\n      index = array.indexOf(item);\n    }\n\n    found = !(index < 0);\n    if (found) {\n      array.splice(index, 1);\n      removed += 1;\n    }\n  } while (removeAll && found);\n\n  return removed;\n};\n\nexport const getDifferences = () => {\n  let previous = [];\n\n  return (array) => {\n    const plus = array.filter((item) => previous.indexOf(item) < 0);\n    const minus = previous.filter((item) => array.indexOf(item) < 0);\n    previous = [...array];\n\n    return { plus, minus };\n  };\n};\n\nexport const trackChanges = (array) => {\n  let previous = [...array];\n\n  return () => {\n    const plus = array.filter((item) => previous.indexOf(item) < 0);\n    const minus = previous.filter((item) => array.indexOf(item) < 0);\n    previous = [...array];\n\n    return { plus, minus };\n  };\n};\n\nexport const shuffle = (a) => {\n  let ii = a.length;\n\n  while (ii) {\n    const jj = Math.floor(Math.random() * ii);\n    ii -= 1;\n    [a[ii], a[jj]] = [a[jj], a[ii]];\n  }\n\n  return a; // for chaining\n};\n\nexport const getRandom = (max, min = 0) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nexport const getRandomFromArray = (array) => {\n  return array[Math.floor(Math.random() * array.length)];\n};\n\n/**\n * @returns either 0 or 1 but never more than 4 0s or 1s in a row\n *          and most likely not more than 3 in a row\n */\nexport const getBooleanGenerator = () => {\n  const lastFourValues = [0, 1, 0, 1];\n\n  const randomBoolean = (hint = 0) => {\n    const random = Math.max(0, Math.min(1, Math.random() * 2 + hint));\n    return Math.floor(random); // 0 | 1\n  };\n\n  return function booleanGenerator() {\n    let output;\n\n    const sum = lastFourValues.reduce((accumulator, value) => {\n      return accumulator + value;\n    }, 0);\n\n    switch (sum) {\n      case 0:\n        output = 1;\n        break;\n      case 1:\n        output = randomBoolean(0.5);\n        break;\n      case 3:\n        output = randomBoolean(-0.5);\n        break;\n      case 4:\n        output = 0;\n        break;\n      default:\n        output = randomBoolean();\n    }\n\n    lastFourValues.shift();\n    lastFourValues.push(output);\n\n    return output;\n  };\n};\n\nexport const arrayOverlap = (array1, array2) => {\n  if (!array1 || !array1.length || !array2 || !array2.length) {\n    return [];\n  }\n\n  return array1.filter((item) => array2.includes(item));\n};\n\nexport const getUnused = (source, used, tolerateDuplicates) => {\n  const unused = source.slice(0);\n  used.forEach((item) => removeFrom(unused, item));\n  let item = getRandomFromArray(unused);\n\n  if (!item && tolerateDuplicates) {\n    // May return the same item multiple times,\n    // rather than creating a smooth spread\n    item = getRandomFromArray(source);\n  }\n\n  return item;\n};\n\n// MOUSE/TOUCH EVENT FUNCTIONS ///\n// https://gist.github.com/blackslate/6f77d3acd2edc2a286cff6d607cf3ce8\n\n/**\n * DETECT MOVEMENT\n * ---------------\n * Sometimes you want a simple click to perform one action and a drag\n * on the same element to perform a different action. You can create two\n * methods, (say) startDrag() and clickAction(), and use the following\n * function (plus the functions below) to determine which of the two\n * actions will be triggered.\n *\n * let dragMe = <your draggable element>\n *   , cancelDrag // set to a function that will cancel dragging\n *\n * const drop = () => {\n *   // Do whatever needs to be done when dragged element is dropped\n * }\n *\n * const startDrag = (event) => {\n *   const options = {\n *     event\n *   , drop\n *   }\n *\n *   startTracking(options)\n * }\n *\n * const checkForDrag = (event) => {\n *   event.preventDefault()\n *\n *   detectMovement(event, 10, 250)\n *   .then(() => startDrag(event) )\n *   .catch(clickAction)\n * }\n *\n * startDrag will be called if the mouse or touch point moves 10 pixels\n * or more within 250 milliseconds; clickAction will be called if there\n * is no movement within this time, or if the mouse/touch pressure is\n * released before this time.\n *\n * TRACKING\n * --------\n * When dragging an element, you generally want one function to be\n * called for any movement, and another to be triggered when the element\n * is dropped. You don't want to have to create separate code for\n * mouse events and touch events, even if these events generate\n * the current x and y positions in different ways.\n *\n * The startTracking() function allows you to provide a starting\n * event (mouseDown or touchStart) and two functions that should be\n * called: one for mousemove|touchmove and the other for mouseup|\n * touchend.\n *\n * X and Y COORDINATES\n * -------------------\n * You can use getPageXY() to get the current mouse position or the\n * position of the first touch point, without worrying about whether\n * the input is from a mouse or a touch screen.\n *\n * ===============================================================\n * NOTE FOR REACT USERS CREATING WEB APPS FOR TOUCH SCREEN DEVICES\n * ===============================================================\n * React refuses to add non-passive (cancellable) event listeners for\n * touchstart. With a passive event listener, the whole page is likely\n * to move at the same time as the dragged element, which is probably\n * not what you want.\n *\n * As a result, you should NOT use React to pass an onTouchStart\n * function the same way that you would pass an onMouseDown function to\n *  your draggable element.\n *\n * Instead, you need to apply your touchstart event listener directly\n * to the DOM element that you want to drag with useEffect, as shown\n * below.\n *\n * const dragRef = useRef()\n *\n * return (\n *   <main>\n *     <div\n *       onMouseDown={checkForDrag}\n *       ref={dragRef}\n *     />\n *   </main>\n * );\n *\n * useEffect(() => {\n *   dragMe = dragRef.current\n *   dragMe.addEventListener(\"touchstart\", checkForDrag, false)\n * })\n */\n\nexport const getPageXY = (event) => {\n  if (event.targetTouches && event.targetTouches.length) {\n    event = event.targetTouches[0] || {};\n  }\n\n  return { x: event.pageX, y: event.pageY };\n};\n\n/**\n * Returns a promise which will be:\n * * resolved if the mouse or touch moves more than triggerDelta\n *   pixels in any direction\n * * rejected if the mouse is released or the touch gesture ends before\n *   moving that far, or if <timeOut> number of milliseconds elapses\n *   before any movement occurs.\n *\n * @param  {event}  event should be a mousedown or touchstart event\n * @param  {number} triggerDelta should be the number of pixels of\n *                          movement that will resolve the promise\n * @param  {number} timeOut may be a number of milliseconds. Defaults\n *                          to 250. Use 0 for no timeOut rejection.\n *\n * @return  {promise}\n */\nexport const detectMovement = (event, triggerDelta, timeOut) => {\n  const trigger2 = triggerDelta * triggerDelta;\n  timeOut = isNaN(timeOut) ? 250 : Math.abs(timeOut);\n\n  function movementDetected(resolve, reject) {\n    const { x: startX, y: startY } = getPageXY(event);\n    const options = { event, drag, drop };\n    const cancelDrag = startTracking(options);\n\n    // Check if the mouse/touch has moved more than triggerDelta\n    // pixels in any direction, and resolve promise if so.\n    function drag(event) {\n      const { x, y } = getPageXY(event);\n      const deltaX = startX - x;\n      const deltaY = startY - y;\n      const delta2 = deltaX * deltaX + deltaY * deltaY;\n\n      if (delta2 > trigger2) {\n        cancelDrag();\n        resolve();\n      }\n    }\n\n    // Reject promise if the mouse is released before the mouse/touch\n    // moved triggerDelta pixels in any direction.\n    function drop() {\n      cancelDrag();\n      reject(\"release\");\n    }\n\n    if (timeOut) {\n      setTimeout(() => reject(\"timeOut\"), timeOut);\n    }\n  }\n\n  return new Promise(movementDetected);\n};\n\n/**\n * Called by defaultDragAction\n *\n * @param {DOMElement} element\n * @returns  element's closest parent which has a position other than\n *           static\n */\nconst getNonStaticParent = (element) => {\n  let parent;\n  while (element.tagName !== \"BODY\" && (parent = element.parentNode)) {\n    const style = getComputedStyle(parent);\n    if (style.getPropertyValue(\"position\") !== \"static\") {\n      break;\n    }\n\n    element = parent;\n  }\n\n  return parent;\n};\n\n/**\n * If no drag function is supplied, move the target (or its parent)\n * with the mouse or touch. Called by startTracking.\n *\n * @param {MouseEvent | TouchEvent} event\n * @param {String?} selector\n *                  If selector is a string, it will be used to find\n *                  the closest matching parent (or the target itself)\n *                  as the element to drag\n * @param {Objec?}  offset\n *                  If offset is an object with the format\n *                  { x: <Number>, y: <Number> }, then it will be used\n *                  for defining the offset from the drag point to the\n *                  top left of the dragged element.\n * @returns         a function in a closure, which knows which target\n *                  and offset to use\n */\nconst defaultDragAction = (event, selector, rider, offset) => {\n  const target =\n    typeof selector === \"string\"\n      ? event.target.closest(selector) // select an ancestor\n      : event.target;\n\n  const offsetGiven =\n    typeof offset === \"object\" && !isNaN(offset.x) && !isNaN(offset.y);\n\n  if (!offsetGiven) {\n    // Move target relative to its closest non-static parent\n    const fix = getNonStaticParent(target);\n    const { left: fixLeft, top: fixTop } = fix.getBoundingClientRect();\n    const { x, y } = getPageXY(event);\n    const { left, top } = target.getBoundingClientRect();\n    offset = { x: left - fixLeft - x, y: top - fixTop - y };\n  }\n\n  const drag = (event) => {\n    let { x, y } = getPageXY(event);\n    x += offset.x;\n    y += offset.y;\n\n    target.style.left = x + \"px\";\n    target.style.top = y + \"px\";\n\n    if (typeof rider === \"function\") {\n      rider(event, { x, y });\n    }\n  };\n\n  return drag;\n};\n\n// The prevent default function needs to be outside startTracking\n// so that the exact same listener function (rather than a duplicate)\n// can be  removed later.\nconst noDefault = (event) => event.preventDefault();\n\n/**\n * Starts listening for a drag and drop operation, and follows it\n * through to the end. The operation can be cancelled at any time\n * by calling the function returned by startTracking.\n *\n * @param {Object}\n *          event: may be either a MouseDown event or a TouchStart event\n *           drag: may be a custom function to call for dragging. If\n *                 not, a generic function will be used. It may also be\n *                 a CSS selector to define which parent of the clicked\n *                 target should be dragged.\n *           drop: a callback function that will be called when the\n *                 dragging stops\n *         offset: may be an object of the form { x: Number, y: Number}\n *                 to be used by the defaultDragAction function.\n *\n * @returns        a function that can be called to cancelDrag\n *                 (before it starts). However, this function will be\n *                 called automatically when the drag process ends.\n */\nexport function startTracking({ event, drag, rider, drop, offset }) {\n  const body = document.body;\n  const dragOption = { passive: false }; // capture is false by default\n\n  let move, end;\n\n  if (event.type === \"touchstart\") {\n    move = \"touchmove\";\n    end = \"touchend\";\n  } else {\n    move = \"mousemove\";\n    end = \"mouseup\";\n  }\n\n  switch (typeof drag) {\n    case \"function\":\n      // Use the custom function\n      break;\n    default:\n      // case \"string\":\n      // Use the default function. `drag` may be a parent selector.\n      drag = defaultDragAction(event, drag, rider, offset);\n      break;\n  }\n\n  // cancelDrag may be called from outside, before any drag or\n  // drop events have occurred, in which case `event` may be\n  // undefined. If the call was triggeerd by an `end` event, then\n  // the drop function will be called.\n  const cancelDrag = (event) => {\n    body.removeEventListener(move, drag, false);\n    body.removeEventListener(end, cancelDrag, false);\n    // Restore page scrolling on touch devices now that drag is over\n    document.removeEventListener(\"touchstart\", noDefault);\n\n    if (event && typeof drop === \"function\") {\n      drop(event);\n    }\n  };\n\n  body.addEventListener(move, drag, false);\n  body.addEventListener(end, cancelDrag, false);\n  // Prevent the page scrolling during drag, on touch devices\n  document.addEventListener(\"touchstart\", noDefault, dragOption);\n\n  return cancelDrag;\n}\n\n/// RECT & OBJECT FUNCTIONS ///\n\nexport const intersect = (rect1, rect2) => {\n  return (\n    rect1.x < rect2.right &&\n    rect2.x < rect1.right &&\n    rect1.y < rect2.bottom &&\n    rect2.y < rect1.bottom\n  );\n};\n\nexport const intersection = (rect1, rect2) => {\n  const left = Math.max(rect1.left || rect1.x || 0, rect2.left || rect2.x || 0);\n  const right = Math.min(\n    rect1.right || rect1.left + rect1.width || 0,\n    rect2.right || rect2.left + rect2.width || 0\n  );\n  if (!(left < right)) {\n    return 0;\n  }\n\n  const top = Math.max(rect1.top || rect1.y || 0, rect2.top || rect2.y || 0);\n  const bottom = Math.min(\n    rect1.bottom || rect1.top + rect1.height || 0,\n    rect2.bottom || rect2.top + rect2.height || 0\n  );\n  if (!(top < bottom)) {\n    return 0;\n  }\n\n  const x = left;\n  const y = top;\n  const width = right - x;\n  const height = bottom - y;\n\n  return { x, y, left, right, top, bottom, width, height };\n};\n\nexport const union = (rects) => {\n  const [rect, ...rest] = rects;\n  let { left, right, top, bottom } = rect;\n\n  rest.forEach((rect) => {\n    left = Math.min(left, rect.left);\n    right = Math.max(right, rect.right);\n    top = Math.min(top, rect.top);\n    bottom = Math.max(bottom, rect.bottom);\n  });\n\n  const x = left;\n  const y = top;\n  const width = right - left;\n  const height = bottom - top;\n\n  return { x, y, left, right, top, bottom, width, height };\n};\n\nexport const pointWithin = (x, y, rect) => {\n  if (typeof x === \"object\") {\n    if (typeof rect !== \"object\" && typeof y === \"object\") {\n      rect = y;\n      y = x.y;\n      x = x.x;\n    }\n  }\n  return rect.x <= x && rect.y <= y && rect.right > x && rect.bottom > y;\n};\n\n/**\n * Calculates which fraction of rect shares it area with container\n */\nexport const overlap = (rect, container) => {\n  let overlap = intersection(rect, container); // 0 or rect object\n\n  if (overlap) {\n    const width = rect.width || rect.left - rect.right;\n    const height = rect.height || rect.bottom - rect.top;\n    overlap = (overlap.width * overlap.height) / (width * height);\n  }\n\n  return overlap;\n};\n\nexport const valuesMatch = (a, b) => {\n  if (!a || typeof a !== \"object\" || !b || typeof b !== \"object\") {\n    return false;\n  }\n\n  const propsA = Object.getOwnPropertyNames(a);\n  const propsB = Object.getOwnPropertyNames(b);\n\n  if (propsA.length !== propsB.length) {\n    return false;\n  }\n\n  const total = propsA.length;\n  for (let ii = 0; ii < total; ii += 1) {\n    const prop = propsA[ii];\n\n    if (a[prop] !== b[prop]) {\n      return false;\n    }\n\n    if (!removeFrom(propsB, prop)) {\n      // prop is undefined in a and missing in b\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const valuesDontMatch = (a, b) => {\n  const nonMatching = {};\n\n  if (!a || typeof a !== \"object\" || !b || typeof b !== \"object\") {\n    return { a, b };\n  }\n\n  const propsA = Object.getOwnPropertyNames(a);\n  const propsB = Object.getOwnPropertyNames(b);\n\n  propsA.forEach((prop) => {\n    if (propsB.indexOf(prop) < 0) {\n      nonMatching[prop] = [\"delete\", a[prop]];\n    } else {\n      removeFrom(propsB, prop);\n\n      const valueA = a[prop];\n      const valueB = b[prop];\n\n      // if (path) {\n      //   prop = path + \".\"+ prop\n      // }\n\n      if (typeof valueA === \"object\" && typeof valueB === \"object\") {\n        const nested = valuesDontMatch(valueA, valueB);\n        if (nested) {\n          nonMatching[prop] = nested;\n        }\n      } else if (valueA !== valueB) {\n        nonMatching[prop] = [\"change\", getString(valueA), getString(valueB)];\n      }\n    }\n  });\n\n  propsB.forEach((prop) => {\n    if (propsA.indexOf(prop) < 0) {\n      // if (path) {\n      //   prop = path + \".\"+ prop\n      // }\n\n      nonMatching[prop] = [\"insert\", getString(b[prop])];\n    }\n  });\n\n  if (Object.keys(nonMatching).length) {\n    return nonMatching;\n  }\n};\n\nexport const deleteFrom = (object, key, removed) => {\n  if (typeof removed !== \"object\") {\n    removed = {};\n  }\n\n  // If `key` is an array of keys, treat recursively\n  if (Array.isArray(key)) {\n    key.forEach((entry) => deleteFrom(object, entry, removed));\n    return removed;\n  } else if (key === undefined) {\n    key = (key, value) => value === undefined || value === null;\n  }\n\n  // If we get here, key is an individual item\n  if (typeof key === \"function\") {\n    const keys = Object.keys(object);\n    keys.forEach((property) => {\n      const value = object[property];\n      const deleteIt = key(property, value);\n      if (deleteIt) {\n        removed[property] = value;\n        delete object[property];\n      }\n    });\n  } else if (object.hasOwnProperty(key)) {\n    removed[key] = object[key];\n    delete object[key];\n  }\n\n  return removed;\n};\n\n// FONTS //\n\nexport const getFontFamily = (ff) => {\n  const start = ff.indexOf(\"family=\");\n  if (start === -1) return \"sans-serif\";\n  let end = ff.indexOf(\"&\", start);\n  if (end === -1) end = undefined;\n  ff = ff.slice(start + 7, end).replace(\"+\", \" \");\n  ff = '\"' + ff + '\"';\n  return ff; // + ', sans-serif'\n};\n\n// ENCRYPTION\n\n// by bryc https://stackoverflow.com/a/52171480/1927589\nexport const hash = (str, seed = 0) => {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 =\n    Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\n    Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 =\n    Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\n    Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\n\n// IMAGES //\n\n// Inspired by https://ourcodeworld.com/articles/read/683/how-to-remove-the-transparent-pixels-that-surrounds-a-canvas-in-javascript\n// MIT http://rem.mit-license.org\nexport const trimImage = (image) => {\n  const c = document.createElement(\"canvas\");\n  c.width = image.width;\n  c.height = image.height;\n\n  const ctx = c.getContext(\"2d\");\n  ctx.drawImage(image, 0, 0);\n\n  const copy = document.createElement(\"canvas\").getContext(\"2d\");\n  const pixels = ctx.getImageData(0, 0, c.width, c.height);\n  const l = pixels.data.length;\n  const bound = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null,\n  };\n  let ii, x, y;\n\n  // Iterate over every pixel to find the highest\n  // and where it ends on every axis ()\n  for (ii = 0; ii < l; ii += 4) {\n    if (pixels.data[ii + 3] !== 0) {\n      x = (ii / 4) % c.width;\n      y = ~~(ii / 4 / c.width);\n\n      if (bound.top === null) {\n        bound.top = y;\n      }\n\n      if (bound.left === null) {\n        bound.left = x;\n      } else if (x < bound.left) {\n        bound.left = x;\n      }\n\n      if (bound.right === null) {\n        bound.right = x;\n      } else if (bound.right < x) {\n        bound.right = x;\n      }\n\n      if (bound.bottom === null) {\n        bound.bottom = y;\n      } else if (bound.bottom < y) {\n        bound.bottom = y;\n      }\n    }\n  }\n\n  // Calculate the height and width of the content\n  const trimHeight = bound.bottom - bound.top;\n  const trimWidth = bound.right - bound.left;\n  const trimmed = ctx.getImageData(\n    bound.left,\n    bound.top,\n    trimWidth,\n    trimHeight\n  );\n\n  // console.log(bound)\n\n  copy.canvas.width = trimWidth;\n  copy.canvas.height = trimHeight;\n  copy.putImageData(trimmed, 0, 0);\n\n  // Return an image\n  const trimmedImage = new Image();\n  trimmedImage.src = copy.canvas.toDataURL();\n\n  return trimmedImage;\n};\n//\n// window.trimImage = trimImage\n\n// STRINGS //\n\n/** Adds customizable inserts to a string (e.g. Welcome <username>)\n *\n * @param      {string}  phrase   string OR\n *                                { simple:  \"Log in\"\n *                                , replace: \"Log in as ^0\"\n *                                }\n * @param     {object}   options  { \"^0\": \"admin\", ... }\n *\n * @return    {string}   string (with customized inserts)\n */\nexport const substitute = (phrase, options) => {\n  if (options && typeof options === \"object\") {\n    if (typeof phrase === \"object\") {\n      phrase = phrase.replace;\n    }\n\n    for (let key in options) {\n      phrase = phrase.replace(key, options[key]);\n    }\n  } else if (typeof phrase === \"object\") {\n    phrase = phrase.simple;\n  }\n\n  // Replace underscores with non-breaking spaces\n  phrase = phrase.replace(/_/g, \" \");\n\n  return phrase;\n};\n\n/**\n * Returns the best localized string from a map of phrases\n *\n * @param   {object}  phraseData   { ...\n *                                 , \"co-DE\": \"regional string\"\n *                                 , \"co\": \"generic string\"\n *                                 , \"xx\": {\n *                                     simple:  \"Log in\"\n *                                   , replace: \"Log in as ^0\"\n *                                   }\n *                                 , \"zz\": \"String with ^0 to replace\"\n *                                 , ...\n *                                 }\n * @param   {string}  code         language code ≈ \"co\" or \"co-DE\"\n * @param   {object}  options      { \"^0\": \"admin\", ... }\n *                                 OR\n *                                 \"as_is\", in which case any object\n *                                 containing simple and replace\n *                                 strings will be returned as an\n *                                 object\n *                                 OR\n *                                 other values are ignored\n *\n * @return  {string}  \"<Missing>\" or the localized string\n */\nexport const getLocalized = (phraseData, code = \"en\", options) => {\n  let phrase = phraseData[code];\n\n  if (!phrase) {\n    // Check if there is a more generic phrase without the region\n    const stripRegex = /-\\w+/;\n    code = code.replace(stripRegex, \"\"); // \"co-DE\" => \"co\"\n    phrase = phraseData[code];\n\n    if (!phrase) {\n      // Use any regional dialect of English as a fallback\n      const available = Object.keys(phraseData);\n      code = available.find((key) => key.replace(stripRegex) === \"en\");\n\n      if (code) {\n        phrase = phraseData[code];\n      } else {\n        // Use the first available language\n        phrase = phraseData[available[0]];\n      }\n\n      if (!phrase) {\n        phrase = \"<Missing>\";\n      }\n    }\n  }\n\n  if (options !== \"as_is\") {\n    phrase = substitute(phrase, options);\n  }\n\n  return phrase;\n};\n\n/** Selects a localized string from an array and customizes it\n *  replacing any (visible) underscores with (invisible)\n *  non-breaking spaces\n *\n * @param      {string}  cue     string cue value from corpus\n * @param      {string}  code    string language code, like \"co-DE\"\n * @param      {array}   corpus  [ { \"cue\": \"unique_string\"\n *                                 , \"co-DE\": \"fixed string\"\n *                                 , \"co\":    \"variable string ^0\"\n *                                 , ...\n *                                 }\n *                               , ...\n *                               ]\n * @param     {object}   options  { \"^0\": \"changeable part\", ...}\n *\n * @return    {string}   '***cue***' or localized string with &nbsp;\n */\nexport const localize = (cue, code, corpus, options) => {\n  let phrase;\n\n  const phraseData = corpus.find((phrase) => phrase.cue === cue);\n\n  if (phraseData) {\n    phrase = getLocalized(phraseData, code, options);\n  }\n\n  if (!phrase) {\n    console.log(\n      \"Not found — cue:\",\n      cue,\n      \"code:\",\n      code,\n      \"phraseData:\",\n      phraseData\n    );\n    phrase = \"***\" + cue + \"***\";\n  }\n\n  return phrase;\n};\n\nexport const getString = (item) => {\n  const type = typeof item;\n  try {\n    switch (type) {\n      case \"undefined\":\n        return \"undefined\";\n      case \"string\":\n      case \"object\":\n        return item;\n      default:\n        if (item.toString) {\n          return item.toString();\n        } else {\n          return item;\n        }\n    }\n  } catch {\n    return \"Unable to convert \" + type + \": \" + item;\n  }\n};\n\n// HTML ELEMENTS //\n\n/** Returns index of the child of parentTag that contains element\n *\n * This is useful when you want to find (for instance) which list\n * item was selected, given that the event occurred on a child of the\n * list item.\n *\n * @param    {<type>}          element    An HTML element\n * @param    {string}          parentTag  The string tag of the parent\n *                                        of the element that contains\n *                                        `element`. \"UL\" by default.\n * @return   {integer}  -1 if element is not valid or if it does not\n *                      have a parent with the given tag, Non-negative\n *                      integer if the element's parent is found.\n */\nexport const getElementIndex = (element, parentTag) => {\n  let index = -1;\n\n  if (element instanceof HTMLElement) {\n    parentTag = typeof parentTag === \"string\" ? parentTag.toUpperCase() : \"UL\";\n\n    while (element && element.parentNode.tagName !== parentTag) {\n      element = element.parentNode;\n    }\n\n    if (element) {\n      const siblings = [].slice.call(element.parentNode.children);\n      index = siblings.indexOf(element);\n    }\n  }\n\n  return index;\n};\n","/**\n * /src/api/pairs.js\n */\n\nimport { shuffle, removeFrom } from '../tools/utilities'\nconst pairs = require('../json/pairs.json')\nexport const AUDIO_DIR = \"audio/\"\n\n/** Export an array of pairs of phonemes that can be contrasted with\n * each other. This will be imported by the Index component\n */\nexport const phonemePairs = Object.keys(pairs.pairs)\nexport const pairIndex = pairs.index\n\n// let taboo = false\n\nlet currentPair    // \"ɪi\" <<< one of the entries in phonemePairs\nlet pairList       // [ [ \"bitch\", \"beach\" ],...[ \"wheel\", \"will\" ] ]\nlet phonemeSymbols // [ \"ɪ\", \"iː\" ]\nlet phonemes       // [ { symbol: \"/ɪ/\", audio: [0, 1] }, ...]\n// let currentIndex   // 0\n// let lastIndex      // index of list item in pairList\nlet played         // { \"/x/\": [ <card>, ... ]\n                   // , \"/y/\": [ <card>, ... ]\n                   // }\nlet word1, word2   // \"bitch\", \"beach\"\n\n\nexport function getCurrentPair() {\n  return currentPair\n}\n\n\n/**\n * Export a function to set the array of pairs that will produce the\n * next minimal pair of cards\n *\n * @param {string} pair: one ef the items from phonemePairs\n */\nexport function setPhonemePair(pair) {\n  if (currentPair === pair) {\n    return\n  }\n\n  // Choose the given pair, or the first available\n  const index = phonemePairs.indexOf(pair)\n  if (index < 0) {\n    pair = phonemePairs[0]\n  }\n\n  _setPairListAndPhonemeSymbols(pair)\n  // lastIndex = pairList.length - 1\n  // currentIndex = 0\n\n  // Ensure that the pockets start empty\n  word1 = word2 = undefined\n  played = { [phonemeSymbols[0]]:[], [phonemeSymbols[1]]:[] }\n\n  currentPair = pair\n}\n\n\n/**\n * Export a function to return all the data required to display a\n * minimal pair of words and play their audio files\n *\n * @returns\n */\nexport function getCards() {\n  const [ phoneme1, phoneme2 ] = phonemeSymbols\n\n  if (word1) {\n    const spellings = played[phoneme1].map(word => word.spelling)\n    if (spellings.indexOf(word1.spelling) < 0) {\n      played[phoneme1].push(word1)\n      played[phoneme2].push(word2)\n    }\n  }\n\n  // Grab the first card and (for now) move it to the end\n  const cards = pairList.shift()\n  pairList.push(cards)\n\n  word1 = getWordData(phoneme1, cards[0])\n  word2 = getWordData(phoneme2, cards[1])\n\n  removeFrom(played[phoneme1], word1)\n  removeFrom(played[phoneme2], word2)\n\n  const output = {\n    phonemes\n  , word1\n  , word2\n  , played\n  }\n\n  return output\n}\n\n\n/**\n * @param {object} pairMap e.g. {\n *   \"ɑː\": \"ʌ\"       <<< phoneme pair\n * , \"heart\": \"hut\"  <<< minimal pairs\n * , \"barn\": \"bun\"\n * , ...\n * }\n */\nfunction _setPairListAndPhonemeSymbols(pair) {\n  phonemeSymbols = pairs.index[pair].phonemes\n  // [<ɪ>, <æ>]\n\n  pairList = Object.entries(pairs.pairs[pair])\n  // [[<this>, <that>], [<tit>, <tat>], ...]\n\n  phonemes = phonemeSymbols.map(getPhonemeData)\n  shuffle(pairList)\n  // [[<tit>, <tat>], ..., [<this>, <that>], ...]\n}\n\n\n/**\n *\n * @param {string} phoneme (e.g.: \"ɑː\")\n * @param {string} word    (e.g.: \"heart\")\n *\n * @returns an object with a format like:\n * { \"spelling\": \"heart\"\n * , \"phonetic\": \"/hɑːt/\"\n * , \"image\": \"img/ɑ/heart.jpg\"\n * , \"clip\": [2.450, 3.550]\n * , url: \"audio/ɑ.mp3\"\n * }\n */\nexport function getWordData(phoneme, word) {\n  const phonemeData = pairs.words[phoneme]\n  const data = {...phonemeData[word]}\n  data.url = AUDIO_DIR + phonemeData.url\n\n  return data\n}\n\n\n/**\n * Creates an object that allows the app to display the phoneme and\n * play its audio clip\n *\n * @param {string} phoneme (e.g. : \"ɑː\")\n * @returns an object with a format like:\n * { \"clip\": [ <startTime>, <endTime> ]\n * , url: <x.mp3>\n * , phoneme: <x>\n * }\n */\nexport function getPhonemeData(phoneme) {\n  const phonemeData = pairs.words[phoneme]\n  const data = {...phonemeData[phoneme]}\n  data.url = AUDIO_DIR + phonemeData.url\n  data.phoneme = phoneme\n\n  return data\n}\n\n\nsetPhonemePair(\"ɑʌ\")","import React, { useContext, useRef, useState, useEffect } from 'react'\nimport { AudioContext } from './AudioContext'\n\nimport './Activity.css';\nimport CardAndPocket from './CardAndPocket'\n\nimport { getCards } from '../api/pairs'\n\nimport { getBooleanGenerator\n       , detectMovement\n       , startTracking\n       , pointWithin\n       , getPageXY\n} from '../tools/utilities'\nconst getBoolean = getBooleanGenerator()\n\n\n// <<< HARD-CODED\nconst REVIEW_DELAY = 2000;\nconst POCKET_DELAY = 200; // just a little more than transition-duration\nconst PLAY_DELAY = 1000\nconst NEXT_DELAY = 1000\nconst DEAL_DELAY = 300\n// HARD-CODED >>>\n\n\nconst Activity = (props) => {\n  // Shared with all cards and the Play Phoneme buttons\n  const audio = useContext(AudioContext)\n  // Used for animating cue and decoy cards\n  const cueRef = useRef()\n  const decoyRef = useRef()\n  // Used for presenting cards in pocket\n  const phoneme0Ref = useRef()\n  const phoneme1Ref = useRef()\n  const maskRef = useRef()\n  // Used to trigger a re-render with a new card\n  const [counter, setCounter] = useState(0)\n\n  const {\n    phonemes\n  , word1\n  , word2\n  , played: playedCards\n  } = getCards() // imported from pairs.js\n\n  // { \"phonemes\": [\n  //     { phoneme: \"ɪ\", audio: [0, 1], url: \"audio/ɪ.mp3\" }\n  //   , { phoneme: \"iː\", audio: [0, 11], url: \"audio/i.mp3\" }\n  //   ],\n  //   \"word1\": {\n  //     \"spelling\": \"ship\",\n  //     \"phonetic\": \"/∫ɪp/\",\n  //     \"image\": \"img/ship.jpg\",\n  //     \"url\": \"audio/ɪ.mp3\"\n  //     \"audio\": [\n  //       12.34,\n  //       13.24\n  //     ]\n  //   },\n  //   \"word2\": {\n  //     \"spelling\": \"sheep\",\n  //     \"phonetic\": \"/∫iːp/\",\n  //     \"image\": \"img/sheep.jpg\",\n  //     \"url\": \"audio/i.mp3\",\n  //     \"audio\": [\n  //       6.78,\n  //       7.68\n  //     ]\n  //   },\n  //   \"played\" {\n  //     \"ɪ\": [<card>, ...],\n  //     \"iː\": [<card>, ...]\n  //   }\n  // }\n\n  let wrong = false\n  let inProgress = false\n  let cueURL      // source of audio for cue card\n    , cueClip     // [<start>, <end>] of audio for cue card\n    , cueSpace    // cueRef.current: \".cue .card-holder.space\"\n    , cueCard     // div holding .back and .front inside cueSpace\n    , decoyURL\n    , decoyClip\n    , decoySpace  // decoyRef.current: \".decoy .card-holder.space\"\n    , decoyCard   // div holding .back and .front inside decoySpace\n    , phoneme0    // phoneme0Ref.current: <div class=\"phoneme-0 <role>\">\n    , phoneme1    // phoneme1Ref.current: <div class=\"phoneme-1 <role>\">\n    , mask        // maskRef.current\n    , pockets     // [<decoy pocket>, <cue pocket>]\n\n  // drag and drop\n  let cueRect\n    , decoyRect\n\n  // pocket action\n  let cardsAreSpread\n    , visibleCard\n\n\n  const playCue = () => {\n    audio.playClip(cueURL, cueClip)\n  }\n\n\n  // CHECKING THE ANSWER / CHECKING THE ANSWER / CHECKING THE ANSWER //\n\n  const showWrong = () => {\n    if (wrong) {\n      return\n    }\n\n    wrong = true\n    cueCard.classList.remove(\"flipped\")\n    phoneme0.classList.add(\"wrong\")\n    phoneme1.classList.add(\"wrong\")\n\n    cueSpace.classList.add(\"active\", \"outside-pocket\")\n    setTimeout(() => {\n      decoyCard.classList.remove(\"flipped\")\n      decoySpace.classList.add(\"active\", \"reveal\", \"outside-pocket\")\n    }, PLAY_DELAY )\n  }\n\n\n  /**\n   * Move cue card to the appropriate pocket\n   */\n  const showNextCard = () => {\n    cueSpace.classList.remove(\"active\", \"inside-pocket\")\n    decoySpace.classList.remove(\"reveal\", \"active\", \"inside-pocket\")\n\n    cueSpace.classList.add(\"deal\")\n    decoySpace.classList.add(\"deal\")\n\n    setCounter(counter + 1)\n    inProgress = false\n  }\n\n\n  const hideOtherCard = () => {\n    decoySpace.classList.add(\"active\", \"inside-pocket\")\n    setTimeout(showNextCard, NEXT_DELAY)\n  }\n\n\n  const playOtherCard = () => {\n    audio.playClip(decoyURL, decoyClip)\n    setTimeout(hideOtherCard, PLAY_DELAY)\n  }\n\n\n  const showOtherCard = () => {\n    decoyCard.classList.remove(\"flipped\")\n    decoySpace.classList.add(\"reveal\")\n    setTimeout(playOtherCard, POCKET_DELAY)\n  }\n\n\n  const moveIntoPocket = () => {\n    cueSpace.classList.remove(\"outside-pocket\")\n    cueSpace.classList.add(\"inside-pocket\")\n\n    setTimeout(showOtherCard, POCKET_DELAY)\n  }\n\n\n  const moveNearToPocket = () => {\n    cueSpace.classList.add(\"outside-pocket\")\n    setTimeout(moveIntoPocket, POCKET_DELAY)\n  }\n\n\n  const playRightSequence = () => {\n    if (wrong) {\n      return\n    }\n\n    cueSpace.classList.add(\"active\")\n    audio.playClip(cueURL, cueClip)\n    setTimeout(moveNearToPocket, REVIEW_DELAY)\n  }\n\n\n  // Input from pockets and (>) button\n\n  const checkAnswer = event => {\n    const target = event.target\n    if (inProgress ||!target.classList.contains(\"pocket\")) {\n      return\n    } else if (!isNaN(visibleCard)) {\n      return\n    }\n\n    inProgress = true\n    const phoneme = target.closest(\"[class|=phoneme\")\n    // <div class=\"phoneme-X cue|decoy\">\n\n    cueCard.classList.remove(\"flipped\")\n\n    const correct = (phoneme.classList.contains(\"cue\"))\n    if (correct) {\n      playRightSequence()\n    } else {\n      showWrong()\n    }\n  }\n\n\n  const proceed = () => {\n    if (!isNaN(visibleCard)) {\n      unspreadCards()\n    } else {\n      proceedToNextCard()\n    }\n  }\n\n\n  const proceedToNextCard = () => {\n    phoneme0.classList.remove(\"wrong\")\n    phoneme1.classList.remove(\"wrong\")\n\n    cueSpace.classList.remove(\"outside-pocket\")\n    decoySpace.classList.remove(\"outside-pocket\")\n\n    cueSpace.classList.add(\"inside-pocket\")\n    decoySpace.classList.add(\"inside-pocket\")\n\n    // Only after a mistake, not after checking a played card\n    setTimeout(showNextCard, NEXT_DELAY)\n  }\n\n\n  const unspreadCards = () => {\n    phoneme0.classList.remove(\"review\")\n    phoneme1.classList.remove(\"review\")\n\n    const cards = Array.from(document.querySelectorAll(\".pocket-play\"))\n    cards.forEach( card => card.classList.remove(\"pocket-play\"))\n    visibleCard = undefined\n  }\n\n\n  // CUE DRAG AND DROP // CUE DRAG AND DROP // CUE DRAG AND DROP //\n\n  const rider = (event, cardTopLeft) => {\n    const pageLoc = getPageXY(event);\n\n    [cueRect, decoyRect].forEach((rect, index) => {\n      const pocket = pockets[index]\n      const overPocket = pointWithin(pageLoc, rect)\n\n      if (overPocket) {\n        pocket.classList.add(\"hover\")\n      } else {\n        pocket.classList.remove(\"hover\")\n      }\n    })\n  }\n\n\n  const drop = (pageLoc) => {\n    cueSpace.style = {}\n\n    pockets.forEach(pocket => pocket.classList.remove(\"hover\"))\n\n    if (pointWithin( pageLoc, cueRect)) {\n      playRightSequence()\n\n    } else if (pointWithin( pageLoc, decoyRect)) {\n      showWrong()\n\n    } else {\n      return // don't flip the card\n    }\n\n    cueCard.classList.remove(\"flipped\")\n\n  }\n\n\n  const startDrag = (event) => {\n    cueSpace.style.transitionDuration = \"0s\"\n\n    const cuePocket = document.querySelector(\".cue .pocket\")\n    const decoyPocket = document.querySelector(\".decoy .pocket\")\n    cueRect = cuePocket.getBoundingClientRect()\n    decoyRect = decoyPocket.getBoundingClientRect()\n\n    const options = {\n      event\n    , target: cueSpace\n    , drag: \".space\"\n    , rider\n    , drop\n    }\n\n    startTracking(options)\n  }\n\n\n  const checkForDrag = (event) => {\n    // console.log(\"event.type:\", event.type)\n    const target = event.target.closest(\".space\")\n\n    if (target) {\n      const classList = target.classList\n\n      if (classList.contains(\"active\") || classList.contains(\"reveal\")) {\n        return playCue()\n      }\n    }\n\n    detectMovement(event, 16, 0)\n    .then(\n      () => startDrag(event)\n     )\n    .catch(playCue)\n  }\n\n\n  // POCKET CLICK OR DRAG, AND PLAY // POCKET CLICK OR DRAG, AND PLAY //\n\n  const pocketCard = (event) => {\n    // Determine which card from the pocket was clicked. (This means\n    // that the cards can be spread, so that the clicked card is not\n    // necessarilly the top one.)\n    const card = event.target.closest(\".card-holder\")\n    const item = card.closest(\"li\")\n    const list = card.closest(\"ul\")\n    const index = Array.from(list.children).indexOf(item)\n\n    // Determine which phoneme the clicked card uses: 0 or 1\n    const className = list.parentNode.className\n    const phoneme = parseInt(/phoneme-(\\d)/.exec(className)[1], 10)\n\n    // Get the text and audio data for the clicked card\n    const phonemeData = playedCards[phonemes[phoneme].phoneme][index]\n    const { url, clip, spelling } = phonemeData\n\n    return {\n      card\n    , index\n    , phoneme\n    , url\n    , clip\n    , spelling // not yet used\n    }\n  }\n\n\n  const pocketAction = (event) => { //}, url, clip, word) => {\n    const { card, index, phoneme, url, clip } = pocketCard(event)\n\n    // <<< NOT YET IMPLEMENTED\n    if (cardsAreSpread) {\n      if (visibleCard === index) {\n        return audio.play(url, clip)\n      }\n\n      return makeCardVisible(index)\n    }\n    // NOT YET IMPLEMENTED >>>\n\n    detectMovement(event, 16, 500)\n      .then(\n        // The user dragged the card within 500 ms\n        () => prepareToSpreadCards(index, phoneme)\n      )\n      .catch(\n        (reason) => {\n          switch (reason) {\n            default: return\n            case \"release\":\n              // Simple click: show card, play audio, then hide it\n              return playFromPocket(card, url, clip)\n            case \"timeOut\":\n              // Long click\n              return spreadCards(index, phoneme)\n          }\n        }\n      )\n  }\n\n\n  const showCardOutsidePocket = (card) => {\n    mask.classList.add(\"pocket-play\")\n    card.classList.add(\"pocket-play\")\n  }\n\n\n  const showCardsOutsidePocket = (cards) => {\n    mask.classList.add(\"pocket-play\")\n    cards.forEach(card => card.classList.add(\"pocket-play\"))\n    phoneme0.classList.add(\"review\")\n    phoneme1.classList.add(\"review\")\n  }\n\n\n  const playFromPocket = (card, url, clip) => {\n    showCardOutsidePocket(card)\n\n    audio.playClip(url, clip)\n\n    if (isNaN(visibleCard)) {\n      // The cards are not spread\n      setTimeout(() => {\n        mask.classList.remove(\"pocket-play\")\n        card.classList.remove(\"pocket-play\")\n        }\n      , PLAY_DELAY\n      )\n    }\n  }\n\n\n  const prepareToSpreadCards = (index, phoneme) => {\n    // LEAVE FULL CARD SPREAD UNTIL LATER\n    spreadCards(index, phoneme)\n\n    // TODO\n    // start dragging card\n    // limit movement to one axis\n\n\n    // finally(spreadCards)\n  }\n\n  const makeCardVisible = (word) => {\n    // Adjust other cards in this list\n    // Adjust all cards in matching list\n    // Set this card to visibleCard\n  }\n\n\n  const spreadCards = (cardIndex, phonemeIndex) => {\n    visibleCard = cardIndex\n\n    const cards = [phoneme0, phoneme1].map(( phoneme, index ) => {\n      const list = phoneme.querySelector(\"ul\")\n      const item = list.children[cardIndex]\n      const card = item.children[0]\n\n      if (index === phonemeIndex) {\n        const phoneme = phonemes[phonemeIndex].phoneme // e.g. \"ɪ\"\n        const cardData = playedCards[phoneme][cardIndex]\n        const { url, clip } = cardData\n        audio.playClip(url, clip)\n      }\n\n      return card\n    })\n\n    showCardsOutsidePocket(cards)\n  }\n\n\n  // GENERATING THE ACTIVITY LAYOUT // GENERATING THE ACTIVITY LAYOUT //\n\n  const createPockets = () => {\n    const useSecondCard = getBoolean()\n    let cueAction\n\n    const pockets = phonemes.map((phonemeData, index) => {\n      // phonemeData = { phoneme, url, clip }\n\n      // Determine if this card is cue or decoy\n      const [ role, cardRef ]     = (index === useSecondCard)\n                                  ? [ \"decoy\", decoyRef ]\n                                  : [ \"cue\", cueRef]\n\n      // All the other properties depend on the phoneme\n      const [ cardData, pocketRef ] = index\n                                  ? [ word2, phoneme1Ref ]\n                                  : [ word1, phoneme0Ref ]\n      const played = playedCards[phonemeData.phoneme]\n\n      if (index !== useSecondCard) {\n        cueURL = cardData.url\n        cueClip = cardData.clip\n        cueAction = checkForDrag\n\n      } else {\n        decoyURL = cardData.url\n        decoyClip = cardData.clip\n        cueAction = null\n      }\n\n      return <CardAndPocket\n        index={index}\n        cardData={cardData}\n        phonemeData={phonemeData}\n        role={role}\n        cardRef={cardRef}\n        ref={pocketRef}\n        played={played}\n        cueAction={cueAction}\n        pocketAction={pocketAction}\n      />\n    })\n\n    if (useSecondCard) {\n      // Show the cue card on top, by rendering it last\n      pockets.push(pockets.shift())\n    }\n\n    return pockets\n  }\n\n\n  const [ pocket1, pocket2 ] = createPockets()\n\n\n  useEffect(() => {\n    // eslint-disable-next-line\n    cueSpace = cueRef.current\n    // eslint-disable-next-line\n    decoySpace = decoyRef.current\n    // eslint-disable-next-line\n    phoneme0 = phoneme0Ref.current\n    // eslint-disable-next-line\n    phoneme1 = phoneme1Ref.current\n    // eslint-disable-next-line\n    mask = maskRef.current\n\n    // Pointers to DOM elements\n    if (phoneme0.classList.contains(\"cue\")) {\n      // eslint-disable-next-line\n      pockets = [\n        phoneme0.querySelector(\".pocket\")\n      , phoneme1.querySelector(\".pocket\")\n      ]\n    } else {\n      pockets = [\n        phoneme1.querySelector(\".pocket\")\n      , phoneme0.querySelector(\".pocket\")\n      ]\n    }\n\n    // eslint-disable-next-line\n    cueCard = cueSpace.querySelector(\".card\")\n    // eslint-disable-next-line\n    decoyCard = decoySpace.querySelector(\".card\")\n\n    decoySpace.classList.remove(\"deal\")\n    setTimeout(() => {\n      cueSpace.classList.remove(\"deal\")\n      playCue()\n    }, DEAL_DELAY )\n  })\n\n\n  return (\n    <div\n      className=\"activity\"\n      onClick={checkAnswer}\n    >\n      {pocket1}\n      {pocket2}\n      <div\n        id=\"mask\"\n        ref={maskRef}\n      />\n      <p className=\"rule\">Tap or drag to here</p>\n      <button\n        className=\"done\"\n        onClick={proceed}\n      >\n        ➤\n      </button>\n    </div>\n  )\n}\n\nexport default Activity;\n","import React, { useState, useRef, useEffect } from \"react\";\nimport { AudioProvider } from \"./AudioContext\"\n\nimport Views from \"../api/views\";\nimport Menu from \"./Menu\";\n\n\nlet mainElement\n\n\nconst App = (props) => {\n  const [ view, setView ] = useState(\"About\")\n  const mainRef = useRef()\n\n\n  const selectFromMenu = (newView) => {\n    if (typeof newView !== \"string\") {\n      newView = \"Activity\"\n    }\n\n    setView(newView)\n  }\n\n\n  const classNameIsSet = (className) => {\n    if (!mainElement) {\n      console.log(\"Can't get className until mainElement is initialized\")\n      return\n    }\n\n    return mainElement.classList.contains(className)\n  }\n\n\n  const toggleClassName = (className, on) => {\n    if (!mainElement) {\n      console.log(\"Can't set className until mainElement is initialized\")\n      return\n    }\n\n    if (on === false) {\n      mainElement.classList.remove(className)\n    } else {\n      mainElement.classList.add(className)\n    }\n  }\n\n\n  useEffect(() => {\n    mainElement = mainRef.current\n  }, [])\n\n\n  const View = Views[view];\n\n  return (\n    <AudioProvider>\n      <main\n        className=\"split show-cue-image\"\n        ref={mainRef}\n      >\n        <View\n          startActivity={selectFromMenu}\n          toggleClassName={toggleClassName}\n          classNameIsSet={classNameIsSet}\n        />\n        <Menu\n          selectFromMenu={selectFromMenu}\n        />\n      </main>\n    </AudioProvider>\n  );\n}\n\nexport default App;\n","/**\n * /src/components/Contact.jsx\n */\n\n\nimport React from 'react';\n\n\nconst Contact = (props) => {\n return (\n   <h1>Contact page goes here</h1>\n )\n}\n\n\nexport default Contact","/**\n * /src/components/Index.jsx\n */\n\n\n \nimport React, { useContext } from 'react';\nimport { AudioContext } from '../components/AudioContext'\nimport {\n  pairIndex\n, phonemePairs\n, getCurrentPair\n, setPhonemePair\n, getWordData\n, getPhonemeData\n} from '../api/pairs'\n\nimport './Index.css';\n\n// console.log(\"phonemePairs:\", phonemePairs)\n// Array [ \"ɪi\", \"ɑʌ\" ]\n\n\nconst Index = (props) =>  {\n  console.log(\"props:\", props)\n  const audio = useContext(AudioContext)\n\n  const current = getCurrentPair()\n\n  const itemClicked = (pair) => {\n    setPhonemePair(pair)\n    props.startActivity()\n  }\n\n  const getPhonemeButton = ({ phoneme, url, clip }) => {\n    return (\n      <button\n        key={phoneme}\n        className=\"phoneme\"\n        onClick={() => audio.playClip(url, clip)}\n      >\n        /{phoneme}/\n      </button>\n    )\n  }\n\n  const getWordButton = (wordData, index) => {\n    const { spelling: word, url, image, clip } = wordData\n\n    const set = index\n              ? <><img src={image} alt=\"{word}\" /><span>{word}</span></>\n              : <><span>{word}</span><img src={image} alt=\"{word}\" /></>\n\n    return (\n      <button\n        key={word}\n        className=\"word\"\n        onClick={() => audio.playClip(url, clip)}\n      >\n        {set}\n      </button>\n    )\n  }\n\n  const getProgress = (pair) => {\n    return (\n      <div\n        className=\"progress\"\n      >\n        <div\n          style={{width:\"50%\"}}\n        />\n      </div>\n    )\n  }\n\n  const getSelectButton = (pair) => {\n    return (\n      <button\n        key=\"select\"\n        className=\"select\"\n        onClick={() => itemClicked(pair)}\n      >\n        ➤\n      </button>\n    )\n  }\n\n  const pairsArray = phonemePairs.map( pair => {\n    // pair = \"ɪi\"\n    const pairData = pairIndex[pair]\n    const className = (pair === current)\n                    ? \"current\"\n                    : \"\"\n\n    // { phonemes: [\"ɪ\", \"iː\"]\n    // , words: [\"ship\", \"sheep\"]\n    // ... }\n    const phonemes = pairData.phonemes\n    const words = pairData.words\n    const phonemeButtons = []\n    const wordButtons = []\n    let progress\n      , select\n\n    phonemes.forEach((phoneme, index) => {\n      const phonemeData = getPhonemeData(phoneme)\n      //                  wordSets[phoneme]\n      // { \"url\": \"i.mp3\"\n      // , \"iː\": {\n      //     \"clip\": [0.0, 0.85]\n      //   }\n      // , ...\n      // , \"sheep\": {...}\n      // }\n      // const url = phonemeData.url\n      // const clip = phonemeData[phoneme].clip\n      const word = words[index]\n      const wordData = getWordData(phoneme, word)\n      //                phonemeData[word]\n      // { \"spelling\": \"sheep\"\n      // , \"phonetic\": \"/∫iːp/\"\n      // , \"image\": \"img/i/sheep.jpg\"\n      // , \"clip\": [6.15, 7.30]\n      // , \"url\": \"audio/i/mp3\"\n      // }\n      phonemeButtons.push(getPhonemeButton(phonemeData))\n      wordButtons.push(getWordButton(wordData, index))\n      progress = getProgress(pair)\n      select = getSelectButton(pair)\n    })\n\n    const entry = [...phonemeButtons, ...wordButtons, progress, select]\n    \n    return (\n      <li\n        key={pair}\n        className={className}\n      >\n        {entry}\n      </li>\n    )\n  })\n  \n\n  return (\n    <ul\n      id=\"index\"\n    >\n      {pairsArray}\n    </ul>\n  )\n}\n\n\nexport default Index","/**\n * import/tools/storage.js\n *\n * Exports a singleton Storage instance which reads from and writes to\n * localStorage, if it's available, or just pretends to do so if it's\n * not.\n */\n\n\n\n/**\n * If window.localStorage is not available, an instance of the\n * CustomStorage class will be used instead. No data will be saved\n * to the user's hard drive, and no errors will occur.\n *\n * @class      CustomStorage (name)\n */\nclass CustomStorage{\n  constructor() {\n    this.storage = {}\n  }\n\n  // Called by _save() in Storage instance\n  setItem(key, value) {\n    this.storage[key] = value\n  }\n}\n\n\n\nclass Storage{\n  constructor() {\n    /// <<< HARD-CODED\n    this.id = \"jazyx_minimalpairs\"\n    /// HARD-CODED >>>\n\n    this.stored = false // let's be pessimistic\n\n    try {\n      this.storage = window.localStorage\n      this.settings = JSON.parse(this.storage.getItem(this.id))\n      // may be null\n      this.stored = true // we can be optimistic now\n\n    } catch(error) {\n      this.storage = new CustomStorage()\n    }\n\n    if (!this.settings || typeof this.settings !== \"object\") {\n      this.settings = {}\n    }\n  }\n\n\n  setItem(key, value) {\n    this.settings[key] = value\n    this._save()\n    return this.stored // false for a simulation\n  }\n\n\n  set(settings) {\n    Object.assign(this.settings, settings)\n    this._save()\n    return this.stored // false for a simulation\n  }\n\n\n  getItem(key) {\n    return this.settings[key]\n  }\n\n\n  get(defaultValues) {\n    if (typeof defaultValues !== \"object\") {\n      defaultValues = {}\n    }\n    return Object.assign({}, defaultValues, this.settings)\n  }\n\n\n  restore(settings) {\n    Object.assign(settings, this.settings)\n  }\n\n\n  _save() {\n    const string = JSON.stringify(this.settings)\n    this.storage.setItem(this.id, string)\n  }\n}\n\n\n\nexport default new Storage()","/**\n * /src/components/Preferences.jsx\n */\n\n\n/**\n * Text:\n * - show word\n * - show phonetic\n * - hide\n * Landscape layout\n *   Left | Right-handed\n *   Split layout when the screen is wide enough\n * Show|Hide cue image\n * Interface language\n * Target language\n */\n\n\nimport React, { useState } from 'react';\nimport storage from '../tools/storage';\n\n// Read localStorage values or use default preferences on first use\nconst store = storage.get({\n  leftHanded: false\n, split: true\n, showCue: true\n, showPhonetic: false\n})\n\n\nconst Preferences = ({ classNameIsSet, toggleClassName, startActivity }) => {\n  // Preferences will be set from store only the first time. The\n  // saved state will be used thereafter.\n  const [ leftHanded, setLeftHanded ] = useState(store.leftHanded)\n  const [ split, setSplit ] = useState(store.split)\n  const [ showCue, setShowCue ] = useState(store.showCue)\n  const [ showPhonetic, setShowPhonetic ] = useState(store.showPhonetic)\n\n\n  const toggleLeftHanded = () => {\n    const newValue = !leftHanded\n\n    toggleClassName(\"left-handed\", newValue)\n    setLeftHanded(newValue)\n    storage.setItem(\"leftHanded\", newValue)\n  }\n\n\n  const toggleSplit = () => {\n    const newValue = !split\n\n    toggleClassName(\"split\", newValue)\n    setSplit(newValue)\n    storage.setItem(\"split\", newValue)\n  }\n\n\n  const toggleShowCue = () => {\n    const newValue = !showCue\n\n    toggleClassName(\"show-cue-image\", newValue)\n    setShowCue(newValue)\n\n    storage.setItem(\"showCue\", newValue)\n  }\n\n\n  const toggleShowPhonetic = () => {\n    const newValue = !showPhonetic\n\n    toggleClassName(\"show-phonetic\", newValue)\n    setShowPhonetic(newValue)\n\n    storage.setItem(\"showPhonetic\", newValue)\n  }\n\n\n  return (\n    <div id=\"preferences\">\n      <h1>Preferences</h1>\n      <fieldset>\n        <legend>Display</legend>\n        <label htmlFor=\"left-handed\">\n          Left-handed\n          <input\n            id=\"left-handed\"\n            type=\"checkbox\"\n            defaultChecked={leftHanded}\n            onChange={toggleLeftHanded}\n          />\n          <span className=\"slot\">\n            <span className=\"slider\" />\n          </span>\n          Right-handed\n        </label>\n\n\n        <label htmlFor=\"split\">\n          <input\n            id=\"split\"\n            type=\"checkbox\"\n            defaultChecked={split}\n            onChange={toggleSplit}\n          />\n          <span className=\"slot\">\n            <span className=\"slider\" />\n          </span>\n          Use split layout in landscape mode\n        </label>\n\n        <label htmlFor=\"showCue\">\n          <input\n            id=\"showCue\"\n            type=\"checkbox\"\n            defaultChecked={showCue}\n            onChange={toggleShowCue}\n          />\n          <span className=\"slot\">\n            <span className=\"slider\" />\n          </span>\n          Show cue image\n        </label>\n\n\n        <label htmlFor=\"showPhonetic\">\n          <input\n            id=\"showPhonetic\"\n            type=\"checkbox\"\n            defaultChecked={showPhonetic}\n            onChange={toggleShowPhonetic}\n          />\n          <span className=\"slot\">\n            <span className=\"slider\" />\n          </span>\n          Always show phonetic spelling\n        </label>\n      </fieldset>\n\n      <button\n        className=\"continue\"\n        onClick={startActivity}\n      >\n        Continue\n      </button>\n    </div>\n )\n}\n\n\nexport default Preferences","import About from '../components/About'\nimport Activity from '../components/Activity'\nimport Contact from '../components/Contact'\nimport Index from '../components/Index'\nimport Preferences from '../components/Preferences'\nimport Splash from '../components/Splash'\n\nconst Views = {\n  About\n, Activity\n, Contact\n, Index\n, Preferences\n, Splash\n}\n\nexport default Views","/**\n * /src/components/Splash.jsx\n */\n\n\nimport React from 'react';\n// import './Splash.css'\n\n\nconst Splash = (props) => {\n  return <h1>Splash screen</h1>\n}\n\n\nexport default Splash","/**\n * Creates an SVG hamburger menu\n */\n\n\nimport React from 'react';\n\nconst Icon = () => (\n  <g className=\"menu\">\n    <path d=\"\n      M5,20\n      L5,80\n      H95\n      L95,20\n      z\" opacity=\"0\" />\n    <path d=\"\n      M15,10\n      H85\n      a 10 10 180 0 1 0 20\n      H15\n      a 10 10 180 0 1 0 -20\n      z\" />\n    <path d=\"\n      M15,40\n      H85\n      a 10 10 180 0 1 0 20\n      H15\n      a 10 10 180 0 1 0 -20\n      z\" />\n    <path d=\"\n      M15,70\n      H85\n      a 10 10 180 0 1 0 20\n      H15\n      a 10 10 180 0 1 0 -20\n      z\" />\n  </g>\n)\n\nexport default Icon","/**\n * \n */\n\nimport './FullScreen.css'\n\nexport const FullScreenButton = (props) => {\n  const toggleFullScreen = () => {\n    const docElm = document.documentElement;\n    if (docElm.requestFullscreen) {\n        docElm.requestFullscreen();\n    } else if (docElm.mozRequestFullScreen) {\n        docElm.mozRequestFullScreen();\n    } else if (docElm.webkitRequestFullScreen) {\n        docElm.webkitRequestFullScreen();\n    } else if (docElm.msRequestFullscreen) {\n        docElm.msRequestFullscreen();\n    }\n\n    if (document.exitFullscreen) {\n      document.exitFullscreen().catch(()=>{});\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen().catch(()=>{});\n    } else if (document.webkitCancelFullScreen) {\n      document.webkitCancelFullScreen().catch(()=>{});\n    } else if (document.msExitFullscreen) {\n      document.msExitFullscreen().catch(()=>{});\n    }\n  }\n\n  const isIOS = (() => {\n    var iosQuirkPresent = function () {\n        var audio = new Audio();\n\n        audio.volume = 0.5;\n        return audio.volume === 1;   // volume cannot be changed from \"1\" on iOS 12 and below\n    };\n\n    var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);\n    var isAppleDevice = navigator.userAgent.includes('Macintosh');\n    var isTouchScreen = navigator.maxTouchPoints >= 1;   // true for iOS 13 (and hopefully beyond)\n\n    return isIOS || (isAppleDevice && (isTouchScreen || iosQuirkPresent()));\n  })();\n  // https://stackoverflow.com/a/62094756/1927589pd\n  \n  const SVGButton = () => (\n    <svg\n      id=\"fullscreen-btn\"\n      xmlns=\"http://www.w3.org/2100/svg\"\n      viewBox=\"0 0 100 100\"\n      onMouseUp={toggleFullScreen}\n      onClick={props.onClick}\n    >\n\n      <rect\n        width=\"100\"\n        height=\"100\"\n        stroke=\"white\"\n        strokeWidth=\"1\"\n        opacity=\"0\"\n      />\n\n      <path\n        className=\"collapse\"\n        d=\"\n          M 45 55\n          v 27\n          a 5 5 0 0 1 -10 0\n          v -10\n          l -21 21\n          a 5 5 0 0 1 -7.07 -7.07\n          l 21 -21\n          h -10\n          a 5 5 0 0 1 0 -10\n          Z\n\n          M 55 45\n          v -27\n          a 5 5 0 0 1 10 0\n          v 10\n          l 21 -21\n          a 5 5 0 0 1 7.07 7.07\n          l -21 21\n          h 10\n          a 5 5 0 0 1 0 10\n          Z\n        \"\n      />\n\n      <path\n        className=\"expand\"\n        d=\"\n          M 95 5\n          v 27\n          a 5 5 0 0 1 -10 0\n          v -10\n          l -21 21\n          a 5 5 0 0 1 -7.07 -7.07\n          l 21 -21\n          h -10\n          a 5 5 0 0 1 0 -10\n          Z\n\n          M 5 95\n          v -27\n          a 5 5 0 0 1 10 0\n          v 10\n          l 21 -21\n          a 5 5 0 0 1 7.07 7.07\n          l -21 21\n          h 10\n          a 5 5 0 0 1 0 10\n          Z\n        \"\n      />\n    </svg>\n  )\n\n  let component = isIOS ? \"\" : SVGButton()\n  \n  if (component && props.asListItem) {\n    component = (\n      <li\n        className=\"fullscreen\"\n        key=\"fullscreen\"\n      >\n        {component}\n      </li>\n    )\n  }\n\n  return component\n}","/**\n * /src/components/MenuItems.jsx\n */\n\n\nimport React, { Fragment } from 'react';\nimport { FullScreenButton } from './FullScreen'\n\nconst MenuItems = ({ itemSelected }) => {\n  return (\n    <>\n      <FullScreenButton\n        onClick={itemSelected}\n      />\n      <li\n        className=\"unselectable\"\n        key=\"index\"\n        onClick={() => itemSelected(\"Index\")}\n      >\n        Select phoneme pair\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"activity\"\n        onClick={() => itemSelected(\"Activity\")}\n      >\n        Return to activity\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"preferencs\"\n        onClick={() => itemSelected(\"Preferences\")}\n      >\n        Preferences\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"about\"\n        onClick={() => itemSelected(\"About\")}\n      >\n        About this activity\n      </li>\n\n      <li\n        className=\"unselectable\"\n        key=\"contact\"\n        onClick={() => itemSelected(\"Contact\")}\n      >\n        Contact us\n      </li>\n    </>\n  )\n}\n\n\nexport default MenuItems","/**\n * /imports/ui/Menu.jsx\n *\n * The Menu consists of three parts:\n * 1. A full-height background that slides in and out\n * 2. A list of clickable item that is a child of the background\n * 3. A hamburger icon which:\n *    • Is always visible\n *    • Slides out in sync with the background when the background's\n *      right edge is flush with the icon's right edge\n *    • Slides back in in sync with the background, until the\n *      background's right edge is less than the icon's width\n *    • Becomes semi-transparent when the background is not showing\n *    • Brightenes to full opacity when the background slides out\n * Clicking on the hamburger icon makes the background slide out or\n * back in again. Clicking anywhere outside the background while it\n * is visible will make it slide back in again.\n *\n * Clicking on on of the clickable items in the list will trigger\n * that item and slide the menu back in.\n */\n\nimport React, { Component } from 'react';\nimport './Menu.css';\nimport Icon from './MenuIcon'\nimport MenuItems from './MenuItems'\n\n\nconst CLOSE_MENU_DELAY = 1000\n\n\nconst Items = (props) => {\n  const { closeMenu, selectFromMenu, pane, className } = props\n\n  const itemSelected = (item) => {\n    closeMenu(true) // force menu to close even if timeOut is active\n    if (typeof item === \"string\") {\n      selectFromMenu(item)\n    }\n  }\n\n  return <ul\n    id=\"items\"\n    className={className}\n    ref={pane}\n  >\n    <MenuItems\n      itemSelected={itemSelected}\n    />\n  </ul>\n}\n\n\n\nclass Menu extends Component {\n  constructor(props) {\n    super(props)\n\n    this.pane = React.createRef()\n\n    this.callback = props.callback // <<<<<\n\n    this.openMenu = this.openMenu.bind(this)\n    this.closeMenu = this.closeMenu.bind(this)\n    this.state = { open: true }\n\n    this.openMenu()\n    setTimeout(this.closeMenu, CLOSE_MENU_DELAY)\n  }\n\n\n  openMenu(event) {\n    if (this.ignoreOpen) {\n      return\n    }\n\n    if (event) {\n      this.toggleMenu(true)\n    }\n\n    const listener = this.closeMenu\n    document.body.addEventListener(\"touchstart\", listener, true)\n    document.body.addEventListener(\"mousedown\", listener, true)\n  }\n\n\n  closeMenu(event) {\n    // Check if the click was inside the slide-out menu. If not,\n    // close the menu\n\n    if (event && (event === true || event.type === \"touchstart\")) {\n      // Prevent the mouseup from firing right behind\n      this.timeout = setTimeout(() => {\n        this.timeout = 0\n      }, 300)\n      // console.log(\"Menu closeMenu timeout\", this.timeOut)\n    } else if (this.timeout) {\n      return\n    }\n\n    const pane = this.pane.current\n    if (!event || (pane && !pane.contains(event.target))) {\n      this.toggleMenu(false)\n      // Prevent the menu from reopening immediately if the click to\n      // close was on the Icon\n\n      this.ignoreOpen = true\n      setTimeout(() => this.ignoreOpen = false, 100)\n      // console.log(\"Menu closeMenu timeout\", timeOut)\n\n      const listener = this.closeMenu\n      document.body.removeEventListener(\"touchstart\", listener,true)\n      document.body.removeEventListener(\"mousedown\", listener, true)\n    }\n  }\n\n\n  toggleMenu(menu_open) {\n    const open = !this.state.open\n    this.setState({ open })\n  }\n\n\n  render() {\n    const itemClass = this.state.open ? \"open\" : \"\"\n\n    return <div\n        id=\"menu\"\n      >\n        <Items\n          {...this.props}\n          className={itemClass}\n          pane={this.pane}\n          closeMenu={this.closeMenu}\n        />\n        <svg\n          id=\"openMenu\"\n          viewBox=\"0 0 100 100\"\n          preserveAspectRatio=\"xMidYMid meet\"\n\n          onClick={this.openMenu}\n        >\n          <Icon />\n        </svg>\n      </div>\n  }\n}\n\nexport default Menu","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\n// ReactDOM.render(\n//   <React.StrictMode>\n//     <App />\n//   </React.StrictMode>,\n//   document.getElementById('root')\n// );\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\nwindow.addEventListener(\"load\",function() {\n  setTimeout(function(){\n      // This hides the address bar:\n      window.scrollTo(0, 1);\n  }, 0);\n});\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}